{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { createClient } from '@/utils/supabase/server'\r\nimport { revalidatePath } from 'next/cache'\r\nimport { SupabaseClient } from '@supabase/supabase-js'\r\n\r\nexport type ApprovalGroupNode = {\r\n  id: string;\r\n  group_name: string;\r\n  next_approver_group_id: string | null;\r\n  company_id: string;\r\n  is_final_authority: boolean;\r\n  role_count?: number; \r\n}\r\n\r\n// --- SECURITY HELPER ---\r\nasync function requireAuth(supabase: SupabaseClient) {\r\n  const { data: { user } } = await supabase.auth.getUser()\r\n  if (!user) throw new Error(\"Unauthorized\")\r\n\r\n  const { data: profile } = await supabase\r\n    .from('profiles')\r\n    .select('role:role_id(default_role_level)')\r\n    .eq('id', user.id)\r\n    .single()\r\n\r\n  const roleLevel = (profile?.role as any)?.default_role_level || 0\r\n  \r\n  if (roleLevel < 50) {\r\n    throw new Error(\"Insufficient permissions: You must be Staff to edit the Chain of Command.\")\r\n  }\r\n  \r\n  return user\r\n}\r\n\r\n// --- FETCHING ---\r\nexport async function getCompanyChain(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  const { data: companyGroups, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, group_name, next_approver_group_id, company_id, is_final_authority,\r\n      roles:roles(count)\r\n    `)\r\n    .eq('company_id', companyId)\r\n\r\n  if (error) {\r\n    console.error('Error fetching chain:', error)\r\n    return []\r\n  }\r\n\r\n  const formattedGroups = companyGroups.map(g => ({\r\n    ...g,\r\n    role_count: g.roles ? (g.roles as any)[0]?.count || 0 : 0\r\n  })) as ApprovalGroupNode[]\r\n\r\n  const outgoingLinkIds = formattedGroups\r\n    .map(g => g.next_approver_group_id)\r\n    .filter(id => id !== null) as string[];\r\n    \r\n  const existingIds = new Set(formattedGroups.map(g => g.id));\r\n  const missingIds = outgoingLinkIds.filter(id => !existingIds.has(id));\r\n\r\n  if (missingIds.length > 0) {\r\n    const { data: externalGroups } = await supabase\r\n      .from('approval_groups')\r\n      .select('id, group_name, next_approver_group_id, company_id, is_final_authority')\r\n      .in('id', missingIds);\r\n\r\n    if (externalGroups) {\r\n        formattedGroups.push(...(externalGroups as any[]));\r\n    }\r\n  }\r\n\r\n  return formattedGroups;\r\n}\r\n\r\nexport async function getGroupRoles(groupId: string) {\r\n  const supabase = createClient()\r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('approval_group_id', groupId)\r\n    .order('role_name')\r\n  \r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\nexport async function getAllApprovalGroups() {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e) { return [] }\r\n\r\n  const { data, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, \r\n      group_name, \r\n      company:company_id (company_name)\r\n    `)\r\n    .order('group_name')\r\n  \r\n  if (error) return []\r\n  \r\n  return data.map((g: any) => ({\r\n    id: g.id,\r\n    label: `${g.group_name} (${g.company?.company_name || 'No Co.'})`\r\n  }))\r\n}\r\n\r\n\r\n// --- MUTATIONS ---\r\n\r\nexport async function createGroupAction(\r\n  companyId: string, \r\n  groupName: string | null, \r\n  childGroupIdToApprove?: string | null,\r\n  existingGroupId?: string | null\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  let targetParentId = existingGroupId;\r\n\r\n  if (!targetParentId) {\r\n      if (!groupName) return { error: \"Group Name is required for new groups.\" };\r\n\r\n      let nextLink = null;\r\n      \r\n      if (childGroupIdToApprove) {\r\n          const { data: child } = await supabase.from('approval_groups').select('next_approver_group_id').eq('id', childGroupIdToApprove).single();\r\n          nextLink = child?.next_approver_group_id || null;\r\n      }\r\n\r\n      const { data: newGroup, error: createError } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: nextLink,\r\n          is_final_authority: !nextLink\r\n        })\r\n        .select('id')\r\n        .single();\r\n\r\n      if (createError) return { error: createError.message };\r\n      targetParentId = newGroup.id;\r\n  }\r\n\r\n  if (childGroupIdToApprove && targetParentId) {\r\n      const { error: updateError } = await supabase\r\n        .from('approval_groups')\r\n        .update({ \r\n            next_approver_group_id: targetParentId,\r\n            is_final_authority: false\r\n        })\r\n        .eq('id', childGroupIdToApprove);\r\n\r\n      if (updateError) return { error: \"Failed to re-link the chain.\" };\r\n  }\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function createSubordinateGroupAction(\r\n  companyId: string,\r\n  groupName: string | null,\r\n  parentGroupId: string,\r\n  existingGroupId?: string | null\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  if (existingGroupId) {\r\n      const { error } = await supabase\r\n        .from('approval_groups')\r\n        .update({ \r\n            next_approver_group_id: parentGroupId,\r\n            is_final_authority: false \r\n        })\r\n        .eq('id', existingGroupId);\r\n      \r\n      if (error) return { error: error.message };\r\n  } else {\r\n      if (!groupName) return { error: \"Name required.\" };\r\n      const { error } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: parentGroupId,\r\n          is_final_authority: false\r\n        });\r\n      if (error) return { error: error.message };\r\n  }\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function deleteGroupAction(groupId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { count } = await supabase\r\n    .from('roles')\r\n    .select('*', { count: 'exact', head: true })\r\n    .eq('approval_group_id', groupId)\r\n  \r\n  if (count && count > 0) {\r\n    return { error: \"Cannot delete: This group still contains roles. Please move or delete them first.\" }\r\n  }\r\n\r\n  const { data: targetGroup } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', groupId)\r\n    .single();\r\n  \r\n  if (!targetGroup) return { error: \"Group not found\" };\r\n  const parentId = targetGroup.next_approver_group_id;\r\n\r\n  const { error: relinkError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ \r\n        next_approver_group_id: parentId,\r\n        is_final_authority: (parentId === null) \r\n    })\r\n    .eq('next_approver_group_id', groupId);\r\n\r\n  if (relinkError) return { error: \"Failed to re-link children groups.\" };\r\n\r\n  const { error: deleteError } = await supabase\r\n    .from('approval_groups')\r\n    .delete()\r\n    .eq('id', groupId);\r\n\r\n  if (deleteError) return { error: deleteError.message };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n// --- NEW ROLE ASSIGNMENT ACTIONS ---\r\n\r\n// Action 1: Fetch Unassigned Roles for a Company\r\nexport async function getCompanyRoles(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // We want roles that are:\r\n  // 1. Belonging to this company\r\n  // 2. Not assigned to ANY approval group (approval_group_id IS NULL)\r\n  // OR roles that belong to this group (to show current) - but RoleListModal fetches current separately.\r\n  // So here we just want AVAILABLE roles.\r\n  \r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('company_id', companyId)\r\n    .is('approval_group_id', null)\r\n    .order('role_name')\r\n\r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\n// Action 2: Link Role to Group\r\nexport async function assignRoleToGroupAction(roleId: string, groupId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { error } = await supabase\r\n    .from('roles')\r\n    .update({ approval_group_id: groupId })\r\n    .eq('id', roleId)\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}\r\n\r\n// Action 3: Unlink Role from Group\r\nexport async function unassignRoleAction(roleId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { error } = await supabase\r\n    .from('roles')\r\n    .update({ approval_group_id: null })\r\n    .eq('id', roleId)\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}"],"names":[],"mappings":";;;;;;;IAoCsB,kBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { createClient } from '@/utils/supabase/server'\r\nimport { revalidatePath } from 'next/cache'\r\nimport { SupabaseClient } from '@supabase/supabase-js'\r\n\r\nexport type ApprovalGroupNode = {\r\n  id: string;\r\n  group_name: string;\r\n  next_approver_group_id: string | null;\r\n  company_id: string;\r\n  is_final_authority: boolean;\r\n  role_count?: number; \r\n}\r\n\r\n// --- SECURITY HELPER ---\r\nasync function requireAuth(supabase: SupabaseClient) {\r\n  const { data: { user } } = await supabase.auth.getUser()\r\n  if (!user) throw new Error(\"Unauthorized\")\r\n\r\n  const { data: profile } = await supabase\r\n    .from('profiles')\r\n    .select('role:role_id(default_role_level)')\r\n    .eq('id', user.id)\r\n    .single()\r\n\r\n  const roleLevel = (profile?.role as any)?.default_role_level || 0\r\n  \r\n  if (roleLevel < 50) {\r\n    throw new Error(\"Insufficient permissions: You must be Staff to edit the Chain of Command.\")\r\n  }\r\n  \r\n  return user\r\n}\r\n\r\n// --- FETCHING ---\r\nexport async function getCompanyChain(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  const { data: companyGroups, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, group_name, next_approver_group_id, company_id, is_final_authority,\r\n      roles:roles(count)\r\n    `)\r\n    .eq('company_id', companyId)\r\n\r\n  if (error) {\r\n    console.error('Error fetching chain:', error)\r\n    return []\r\n  }\r\n\r\n  const formattedGroups = companyGroups.map(g => ({\r\n    ...g,\r\n    role_count: g.roles ? (g.roles as any)[0]?.count || 0 : 0\r\n  })) as ApprovalGroupNode[]\r\n\r\n  const outgoingLinkIds = formattedGroups\r\n    .map(g => g.next_approver_group_id)\r\n    .filter(id => id !== null) as string[];\r\n    \r\n  const existingIds = new Set(formattedGroups.map(g => g.id));\r\n  const missingIds = outgoingLinkIds.filter(id => !existingIds.has(id));\r\n\r\n  if (missingIds.length > 0) {\r\n    const { data: externalGroups } = await supabase\r\n      .from('approval_groups')\r\n      .select('id, group_name, next_approver_group_id, company_id, is_final_authority')\r\n      .in('id', missingIds);\r\n\r\n    if (externalGroups) {\r\n        formattedGroups.push(...(externalGroups as any[]));\r\n    }\r\n  }\r\n\r\n  return formattedGroups;\r\n}\r\n\r\nexport async function getGroupRoles(groupId: string) {\r\n  const supabase = createClient()\r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('approval_group_id', groupId)\r\n    .order('role_name')\r\n  \r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\nexport async function getAllApprovalGroups() {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e) { return [] }\r\n\r\n  const { data, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, \r\n      group_name, \r\n      company:company_id (company_name)\r\n    `)\r\n    .order('group_name')\r\n  \r\n  if (error) return []\r\n  \r\n  return data.map((g: any) => ({\r\n    id: g.id,\r\n    label: `${g.group_name} (${g.company?.company_name || 'No Co.'})`\r\n  }))\r\n}\r\n\r\n\r\n// --- MUTATIONS ---\r\n\r\nexport async function createGroupAction(\r\n  companyId: string, \r\n  groupName: string | null, \r\n  childGroupIdToApprove?: string | null,\r\n  existingGroupId?: string | null\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  let targetParentId = existingGroupId;\r\n\r\n  if (!targetParentId) {\r\n      if (!groupName) return { error: \"Group Name is required for new groups.\" };\r\n\r\n      let nextLink = null;\r\n      \r\n      if (childGroupIdToApprove) {\r\n          const { data: child } = await supabase.from('approval_groups').select('next_approver_group_id').eq('id', childGroupIdToApprove).single();\r\n          nextLink = child?.next_approver_group_id || null;\r\n      }\r\n\r\n      const { data: newGroup, error: createError } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: nextLink,\r\n          is_final_authority: !nextLink\r\n        })\r\n        .select('id')\r\n        .single();\r\n\r\n      if (createError) return { error: createError.message };\r\n      targetParentId = newGroup.id;\r\n  }\r\n\r\n  if (childGroupIdToApprove && targetParentId) {\r\n      const { error: updateError } = await supabase\r\n        .from('approval_groups')\r\n        .update({ \r\n            next_approver_group_id: targetParentId,\r\n            is_final_authority: false\r\n        })\r\n        .eq('id', childGroupIdToApprove);\r\n\r\n      if (updateError) return { error: \"Failed to re-link the chain.\" };\r\n  }\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function createSubordinateGroupAction(\r\n  companyId: string,\r\n  groupName: string | null,\r\n  parentGroupId: string,\r\n  existingGroupId?: string | null\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  if (existingGroupId) {\r\n      const { error } = await supabase\r\n        .from('approval_groups')\r\n        .update({ \r\n            next_approver_group_id: parentGroupId,\r\n            is_final_authority: false \r\n        })\r\n        .eq('id', existingGroupId);\r\n      \r\n      if (error) return { error: error.message };\r\n  } else {\r\n      if (!groupName) return { error: \"Name required.\" };\r\n      const { error } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: parentGroupId,\r\n          is_final_authority: false\r\n        });\r\n      if (error) return { error: error.message };\r\n  }\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function deleteGroupAction(groupId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { count } = await supabase\r\n    .from('roles')\r\n    .select('*', { count: 'exact', head: true })\r\n    .eq('approval_group_id', groupId)\r\n  \r\n  if (count && count > 0) {\r\n    return { error: \"Cannot delete: This group still contains roles. Please move or delete them first.\" }\r\n  }\r\n\r\n  const { data: targetGroup } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', groupId)\r\n    .single();\r\n  \r\n  if (!targetGroup) return { error: \"Group not found\" };\r\n  const parentId = targetGroup.next_approver_group_id;\r\n\r\n  const { error: relinkError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ \r\n        next_approver_group_id: parentId,\r\n        is_final_authority: (parentId === null) \r\n    })\r\n    .eq('next_approver_group_id', groupId);\r\n\r\n  if (relinkError) return { error: \"Failed to re-link children groups.\" };\r\n\r\n  const { error: deleteError } = await supabase\r\n    .from('approval_groups')\r\n    .delete()\r\n    .eq('id', groupId);\r\n\r\n  if (deleteError) return { error: deleteError.message };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n// --- NEW ROLE ASSIGNMENT ACTIONS ---\r\n\r\n// Action 1: Fetch Unassigned Roles for a Company\r\nexport async function getCompanyRoles(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // We want roles that are:\r\n  // 1. Belonging to this company\r\n  // 2. Not assigned to ANY approval group (approval_group_id IS NULL)\r\n  // OR roles that belong to this group (to show current) - but RoleListModal fetches current separately.\r\n  // So here we just want AVAILABLE roles.\r\n  \r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('company_id', companyId)\r\n    .is('approval_group_id', null)\r\n    .order('role_name')\r\n\r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\n// Action 2: Link Role to Group\r\nexport async function assignRoleToGroupAction(roleId: string, groupId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { error } = await supabase\r\n    .from('roles')\r\n    .update({ approval_group_id: groupId })\r\n    .eq('id', roleId)\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}\r\n\r\n// Action 3: Unlink Role from Group\r\nexport async function unassignRoleAction(roleId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { error } = await supabase\r\n    .from('roles')\r\n    .update({ approval_group_id: null })\r\n    .eq('id', roleId)\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}"],"names":[],"mappings":";;;;;;;IAyMsB,oBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/components/GroupNode.tsx"],"sourcesContent":["// app/manage/roles/components/GroupNode.tsx\r\nimport { ApprovalGroupNode } from '../actions'\r\nimport React from 'react'\r\n\r\ninterface GroupNodeProps {\r\n  node: ApprovalGroupNode\r\n  onDelete: (e: React.MouseEvent) => void\r\n  onAddParent: (e: React.MouseEvent) => void\r\n  onAddSubordinate: (e: React.MouseEvent) => void // <--- NEW\r\n}\r\n\r\nexport default function GroupNode({ node, onDelete, onAddParent, onAddSubordinate }: GroupNodeProps) {\r\n  \r\n  const isFinal = node.is_final_authority\r\n  \r\n  return (\r\n    <div className={`\r\n      relative w-64 p-4 rounded-lg border-2 shadow-md transition-all hover:shadow-lg bg-white dark:bg-gray-800 group\r\n      ${isFinal ? 'border-yellow-500 dark:border-yellow-500 ring-2 ring-yellow-100 dark:ring-yellow-900/30' : 'border-gray-200 dark:border-gray-700'}\r\n    `}>\r\n      \r\n      {/* Header */}\r\n      <div className=\"flex justify-between items-start mb-2\">\r\n        <h3 className=\"font-bold text-gray-900 dark:text-white text-sm leading-tight\">\r\n          {node.group_name}\r\n        </h3>\r\n        <button \r\n            onClick={onDelete}\r\n            className=\"text-gray-400 hover:text-red-600 transition-colors opacity-0 group-hover:opacity-100\"\r\n            title=\"Delete Group\"\r\n        >\r\n            <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" /></svg>\r\n        </button>\r\n      </div>\r\n\r\n      {/* Stats */}\r\n      <div className=\"text-xs text-gray-500 dark:text-gray-400 flex gap-2\">\r\n        <span>Roles: {node.role_count || 0}</span>\r\n        {isFinal && <span className=\"text-yellow-600 font-semibold ml-auto\">Final Authority</span>}\r\n      </div>\r\n\r\n      {/* --- RIGHT BUTTON: Add Approver/Parent (ALWAYS VISIBLE) --- */}\r\n      <div className=\"absolute -right-4 top-1/2 -translate-y-1/2 z-20\">\r\n           <button \r\n             onClick={onAddParent}\r\n             className=\"flex items-center justify-center w-8 h-8 bg-indigo-600 text-white rounded-full shadow-sm hover:bg-indigo-700 hover:scale-110 transition-all border-2 border-white dark:border-gray-800\"\r\n             title=\"Add Next Approver (Parent)\"\r\n           >\r\n             <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 4v16m8-8H4\" /></svg>\r\n           </button>\r\n      </div>\r\n\r\n      {/* --- LEFT BUTTON: Add Subordinate/Child (ALWAYS VISIBLE) --- */}\r\n      <div className=\"absolute -left-4 top-1/2 -translate-y-1/2 z-20\">\r\n           <button \r\n             onClick={onAddSubordinate}\r\n             className=\"flex items-center justify-center w-8 h-8 bg-white dark:bg-gray-700 text-indigo-600 dark:text-indigo-300 rounded-full shadow-sm hover:bg-gray-50 dark:hover:bg-gray-600 hover:scale-110 transition-all border-2 border-indigo-200 dark:border-indigo-700\"\r\n             title=\"Add Feeder Group (Child)\"\r\n           >\r\n             <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 4v16m8-8H4\" /></svg>\r\n           </button>\r\n      </div>\r\n\r\n    </div>\r\n  )\r\n}"],"names":[],"mappings":"AAAA,4CAA4C;;;;;;;AAW7B,SAAS,UAAU,EAAE,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAE,gBAAgB,EAAkB;IAEjG,MAAM,UAAU,KAAK,kBAAkB;IAEvC,qBACE,6LAAC;QAAI,WAAW,CAAC;;MAEf,EAAE,UAAU,4FAA4F,uCAAuC;IACjJ,CAAC;;0BAGC,6LAAC;gBAAI,WAAU;;kCACb,6LAAC;wBAAG,WAAU;kCACX,KAAK,UAAU;;;;;;kCAElB,6LAAC;wBACG,SAAS;wBACT,WAAU;wBACV,OAAM;kCAEN,cAAA,6LAAC;4BAAI,WAAU;4BAAU,MAAK;4BAAO,QAAO;4BAAe,SAAQ;sCAAY,cAAA,6LAAC;gCAAK,eAAc;gCAAQ,gBAAe;gCAAQ,aAAa;gCAAG,GAAE;;;;;;;;;;;;;;;;;;;;;;0BAK1J,6LAAC;gBAAI,WAAU;;kCACb,6LAAC;;4BAAK;4BAAQ,KAAK,UAAU,IAAI;;;;;;;oBAChC,yBAAW,6LAAC;wBAAK,WAAU;kCAAwC;;;;;;;;;;;;0BAItE,6LAAC;gBAAI,WAAU;0BACV,cAAA,6LAAC;oBACC,SAAS;oBACT,WAAU;oBACV,OAAM;8BAEN,cAAA,6LAAC;wBAAI,WAAU;wBAAU,MAAK;wBAAO,QAAO;wBAAe,SAAQ;kCAAY,cAAA,6LAAC;4BAAK,eAAc;4BAAQ,gBAAe;4BAAQ,aAAa;4BAAG,GAAE;;;;;;;;;;;;;;;;;;;;;0BAK3J,6LAAC;gBAAI,WAAU;0BACV,cAAA,6LAAC;oBACC,SAAS;oBACT,WAAU;oBACV,OAAM;8BAEN,cAAA,6LAAC;wBAAI,WAAU;wBAAU,MAAK;wBAAO,QAAO;wBAAe,SAAQ;kCAAY,cAAA,6LAAC;4BAAK,eAAc;4BAAQ,gBAAe;4BAAQ,aAAa;4BAAG,GAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMjK;KAtDwB","debugId":null}},
    {"offset": {"line": 211, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { createClient } from '@/utils/supabase/server'\r\nimport { revalidatePath } from 'next/cache'\r\nimport { SupabaseClient } from '@supabase/supabase-js'\r\n\r\nexport type ApprovalGroupNode = {\r\n  id: string;\r\n  group_name: string;\r\n  next_approver_group_id: string | null;\r\n  company_id: string;\r\n  is_final_authority: boolean;\r\n  role_count?: number; \r\n}\r\n\r\n// --- SECURITY HELPER ---\r\nasync function requireAuth(supabase: SupabaseClient) {\r\n  const { data: { user } } = await supabase.auth.getUser()\r\n  if (!user) throw new Error(\"Unauthorized\")\r\n\r\n  const { data: profile } = await supabase\r\n    .from('profiles')\r\n    .select('role:role_id(default_role_level)')\r\n    .eq('id', user.id)\r\n    .single()\r\n\r\n  const roleLevel = (profile?.role as any)?.default_role_level || 0\r\n  \r\n  if (roleLevel < 50) {\r\n    throw new Error(\"Insufficient permissions: You must be Staff to edit the Chain of Command.\")\r\n  }\r\n  \r\n  return user\r\n}\r\n\r\n// --- FETCHING ---\r\nexport async function getCompanyChain(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  const { data: companyGroups, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, group_name, next_approver_group_id, company_id, is_final_authority,\r\n      roles:roles(count)\r\n    `)\r\n    .eq('company_id', companyId)\r\n\r\n  if (error) {\r\n    console.error('Error fetching chain:', error)\r\n    return []\r\n  }\r\n\r\n  const formattedGroups = companyGroups.map(g => ({\r\n    ...g,\r\n    role_count: g.roles ? (g.roles as any)[0]?.count || 0 : 0\r\n  })) as ApprovalGroupNode[]\r\n\r\n  const outgoingLinkIds = formattedGroups\r\n    .map(g => g.next_approver_group_id)\r\n    .filter(id => id !== null) as string[];\r\n    \r\n  const existingIds = new Set(formattedGroups.map(g => g.id));\r\n  const missingIds = outgoingLinkIds.filter(id => !existingIds.has(id));\r\n\r\n  if (missingIds.length > 0) {\r\n    const { data: externalGroups } = await supabase\r\n      .from('approval_groups')\r\n      .select('id, group_name, next_approver_group_id, company_id, is_final_authority')\r\n      .in('id', missingIds);\r\n\r\n    if (externalGroups) {\r\n        formattedGroups.push(...(externalGroups as any[]));\r\n    }\r\n  }\r\n\r\n  return formattedGroups;\r\n}\r\n\r\nexport async function getGroupRoles(groupId: string) {\r\n  const supabase = createClient()\r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('approval_group_id', groupId)\r\n    .order('role_name')\r\n  \r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\nexport async function getAllApprovalGroups() {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e) { return [] }\r\n\r\n  const { data, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, \r\n      group_name, \r\n      company:company_id (company_name)\r\n    `)\r\n    .order('group_name')\r\n  \r\n  if (error) return []\r\n  \r\n  return data.map((g: any) => ({\r\n    id: g.id,\r\n    label: `${g.group_name} (${g.company?.company_name || 'No Co.'})`\r\n  }))\r\n}\r\n\r\n\r\n// --- MUTATIONS ---\r\n\r\nexport async function createGroupAction(\r\n  companyId: string, \r\n  groupName: string | null, \r\n  childGroupIdToApprove?: string | null,\r\n  existingGroupId?: string | null\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  let targetParentId = existingGroupId;\r\n\r\n  if (!targetParentId) {\r\n      if (!groupName) return { error: \"Group Name is required for new groups.\" };\r\n\r\n      let nextLink = null;\r\n      \r\n      if (childGroupIdToApprove) {\r\n          const { data: child } = await supabase.from('approval_groups').select('next_approver_group_id').eq('id', childGroupIdToApprove).single();\r\n          nextLink = child?.next_approver_group_id || null;\r\n      }\r\n\r\n      const { data: newGroup, error: createError } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: nextLink,\r\n          is_final_authority: !nextLink\r\n        })\r\n        .select('id')\r\n        .single();\r\n\r\n      if (createError) return { error: createError.message };\r\n      targetParentId = newGroup.id;\r\n  }\r\n\r\n  if (childGroupIdToApprove && targetParentId) {\r\n      const { error: updateError } = await supabase\r\n        .from('approval_groups')\r\n        .update({ \r\n            next_approver_group_id: targetParentId,\r\n            is_final_authority: false\r\n        })\r\n        .eq('id', childGroupIdToApprove);\r\n\r\n      if (updateError) return { error: \"Failed to re-link the chain.\" };\r\n  }\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function createSubordinateGroupAction(\r\n  companyId: string,\r\n  groupName: string | null,\r\n  parentGroupId: string,\r\n  existingGroupId?: string | null\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  if (existingGroupId) {\r\n      const { error } = await supabase\r\n        .from('approval_groups')\r\n        .update({ \r\n            next_approver_group_id: parentGroupId,\r\n            is_final_authority: false \r\n        })\r\n        .eq('id', existingGroupId);\r\n      \r\n      if (error) return { error: error.message };\r\n  } else {\r\n      if (!groupName) return { error: \"Name required.\" };\r\n      const { error } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: parentGroupId,\r\n          is_final_authority: false\r\n        });\r\n      if (error) return { error: error.message };\r\n  }\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function deleteGroupAction(groupId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { count } = await supabase\r\n    .from('roles')\r\n    .select('*', { count: 'exact', head: true })\r\n    .eq('approval_group_id', groupId)\r\n  \r\n  if (count && count > 0) {\r\n    return { error: \"Cannot delete: This group still contains roles. Please move or delete them first.\" }\r\n  }\r\n\r\n  const { data: targetGroup } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', groupId)\r\n    .single();\r\n  \r\n  if (!targetGroup) return { error: \"Group not found\" };\r\n  const parentId = targetGroup.next_approver_group_id;\r\n\r\n  const { error: relinkError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ \r\n        next_approver_group_id: parentId,\r\n        is_final_authority: (parentId === null) \r\n    })\r\n    .eq('next_approver_group_id', groupId);\r\n\r\n  if (relinkError) return { error: \"Failed to re-link children groups.\" };\r\n\r\n  const { error: deleteError } = await supabase\r\n    .from('approval_groups')\r\n    .delete()\r\n    .eq('id', groupId);\r\n\r\n  if (deleteError) return { error: deleteError.message };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n// --- NEW ROLE ASSIGNMENT ACTIONS ---\r\n\r\n// Action 1: Fetch Unassigned Roles for a Company\r\nexport async function getCompanyRoles(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // We want roles that are:\r\n  // 1. Belonging to this company\r\n  // 2. Not assigned to ANY approval group (approval_group_id IS NULL)\r\n  // OR roles that belong to this group (to show current) - but RoleListModal fetches current separately.\r\n  // So here we just want AVAILABLE roles.\r\n  \r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('company_id', companyId)\r\n    .is('approval_group_id', null)\r\n    .order('role_name')\r\n\r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\n// Action 2: Link Role to Group\r\nexport async function assignRoleToGroupAction(roleId: string, groupId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { error } = await supabase\r\n    .from('roles')\r\n    .update({ approval_group_id: groupId })\r\n    .eq('id', roleId)\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}\r\n\r\n// Action 3: Unlink Role from Group\r\nexport async function unassignRoleAction(roleId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { error } = await supabase\r\n    .from('roles')\r\n    .update({ approval_group_id: null })\r\n    .eq('id', roleId)\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}"],"names":[],"mappings":";;;;;;;IAiHsB,oBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 226, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { createClient } from '@/utils/supabase/server'\r\nimport { revalidatePath } from 'next/cache'\r\nimport { SupabaseClient } from '@supabase/supabase-js'\r\n\r\nexport type ApprovalGroupNode = {\r\n  id: string;\r\n  group_name: string;\r\n  next_approver_group_id: string | null;\r\n  company_id: string;\r\n  is_final_authority: boolean;\r\n  role_count?: number; \r\n}\r\n\r\n// --- SECURITY HELPER ---\r\nasync function requireAuth(supabase: SupabaseClient) {\r\n  const { data: { user } } = await supabase.auth.getUser()\r\n  if (!user) throw new Error(\"Unauthorized\")\r\n\r\n  const { data: profile } = await supabase\r\n    .from('profiles')\r\n    .select('role:role_id(default_role_level)')\r\n    .eq('id', user.id)\r\n    .single()\r\n\r\n  const roleLevel = (profile?.role as any)?.default_role_level || 0\r\n  \r\n  if (roleLevel < 50) {\r\n    throw new Error(\"Insufficient permissions: You must be Staff to edit the Chain of Command.\")\r\n  }\r\n  \r\n  return user\r\n}\r\n\r\n// --- FETCHING ---\r\nexport async function getCompanyChain(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  const { data: companyGroups, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, group_name, next_approver_group_id, company_id, is_final_authority,\r\n      roles:roles(count)\r\n    `)\r\n    .eq('company_id', companyId)\r\n\r\n  if (error) {\r\n    console.error('Error fetching chain:', error)\r\n    return []\r\n  }\r\n\r\n  const formattedGroups = companyGroups.map(g => ({\r\n    ...g,\r\n    role_count: g.roles ? (g.roles as any)[0]?.count || 0 : 0\r\n  })) as ApprovalGroupNode[]\r\n\r\n  const outgoingLinkIds = formattedGroups\r\n    .map(g => g.next_approver_group_id)\r\n    .filter(id => id !== null) as string[];\r\n    \r\n  const existingIds = new Set(formattedGroups.map(g => g.id));\r\n  const missingIds = outgoingLinkIds.filter(id => !existingIds.has(id));\r\n\r\n  if (missingIds.length > 0) {\r\n    const { data: externalGroups } = await supabase\r\n      .from('approval_groups')\r\n      .select('id, group_name, next_approver_group_id, company_id, is_final_authority')\r\n      .in('id', missingIds);\r\n\r\n    if (externalGroups) {\r\n        formattedGroups.push(...(externalGroups as any[]));\r\n    }\r\n  }\r\n\r\n  return formattedGroups;\r\n}\r\n\r\nexport async function getGroupRoles(groupId: string) {\r\n  const supabase = createClient()\r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('approval_group_id', groupId)\r\n    .order('role_name')\r\n  \r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\nexport async function getAllApprovalGroups() {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e) { return [] }\r\n\r\n  const { data, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, \r\n      group_name, \r\n      company:company_id (company_name)\r\n    `)\r\n    .order('group_name')\r\n  \r\n  if (error) return []\r\n  \r\n  return data.map((g: any) => ({\r\n    id: g.id,\r\n    label: `${g.group_name} (${g.company?.company_name || 'No Co.'})`\r\n  }))\r\n}\r\n\r\n\r\n// --- MUTATIONS ---\r\n\r\nexport async function createGroupAction(\r\n  companyId: string, \r\n  groupName: string | null, \r\n  childGroupIdToApprove?: string | null,\r\n  existingGroupId?: string | null\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  let targetParentId = existingGroupId;\r\n\r\n  if (!targetParentId) {\r\n      if (!groupName) return { error: \"Group Name is required for new groups.\" };\r\n\r\n      let nextLink = null;\r\n      \r\n      if (childGroupIdToApprove) {\r\n          const { data: child } = await supabase.from('approval_groups').select('next_approver_group_id').eq('id', childGroupIdToApprove).single();\r\n          nextLink = child?.next_approver_group_id || null;\r\n      }\r\n\r\n      const { data: newGroup, error: createError } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: nextLink,\r\n          is_final_authority: !nextLink\r\n        })\r\n        .select('id')\r\n        .single();\r\n\r\n      if (createError) return { error: createError.message };\r\n      targetParentId = newGroup.id;\r\n  }\r\n\r\n  if (childGroupIdToApprove && targetParentId) {\r\n      const { error: updateError } = await supabase\r\n        .from('approval_groups')\r\n        .update({ \r\n            next_approver_group_id: targetParentId,\r\n            is_final_authority: false\r\n        })\r\n        .eq('id', childGroupIdToApprove);\r\n\r\n      if (updateError) return { error: \"Failed to re-link the chain.\" };\r\n  }\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function createSubordinateGroupAction(\r\n  companyId: string,\r\n  groupName: string | null,\r\n  parentGroupId: string,\r\n  existingGroupId?: string | null\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  if (existingGroupId) {\r\n      const { error } = await supabase\r\n        .from('approval_groups')\r\n        .update({ \r\n            next_approver_group_id: parentGroupId,\r\n            is_final_authority: false \r\n        })\r\n        .eq('id', existingGroupId);\r\n      \r\n      if (error) return { error: error.message };\r\n  } else {\r\n      if (!groupName) return { error: \"Name required.\" };\r\n      const { error } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: parentGroupId,\r\n          is_final_authority: false\r\n        });\r\n      if (error) return { error: error.message };\r\n  }\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function deleteGroupAction(groupId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { count } = await supabase\r\n    .from('roles')\r\n    .select('*', { count: 'exact', head: true })\r\n    .eq('approval_group_id', groupId)\r\n  \r\n  if (count && count > 0) {\r\n    return { error: \"Cannot delete: This group still contains roles. Please move or delete them first.\" }\r\n  }\r\n\r\n  const { data: targetGroup } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', groupId)\r\n    .single();\r\n  \r\n  if (!targetGroup) return { error: \"Group not found\" };\r\n  const parentId = targetGroup.next_approver_group_id;\r\n\r\n  const { error: relinkError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ \r\n        next_approver_group_id: parentId,\r\n        is_final_authority: (parentId === null) \r\n    })\r\n    .eq('next_approver_group_id', groupId);\r\n\r\n  if (relinkError) return { error: \"Failed to re-link children groups.\" };\r\n\r\n  const { error: deleteError } = await supabase\r\n    .from('approval_groups')\r\n    .delete()\r\n    .eq('id', groupId);\r\n\r\n  if (deleteError) return { error: deleteError.message };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n// --- NEW ROLE ASSIGNMENT ACTIONS ---\r\n\r\n// Action 1: Fetch Unassigned Roles for a Company\r\nexport async function getCompanyRoles(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // We want roles that are:\r\n  // 1. Belonging to this company\r\n  // 2. Not assigned to ANY approval group (approval_group_id IS NULL)\r\n  // OR roles that belong to this group (to show current) - but RoleListModal fetches current separately.\r\n  // So here we just want AVAILABLE roles.\r\n  \r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('company_id', companyId)\r\n    .is('approval_group_id', null)\r\n    .order('role_name')\r\n\r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\n// Action 2: Link Role to Group\r\nexport async function assignRoleToGroupAction(roleId: string, groupId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { error } = await supabase\r\n    .from('roles')\r\n    .update({ approval_group_id: groupId })\r\n    .eq('id', roleId)\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}\r\n\r\n// Action 3: Unlink Role from Group\r\nexport async function unassignRoleAction(roleId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { error } = await supabase\r\n    .from('roles')\r\n    .update({ approval_group_id: null })\r\n    .eq('id', roleId)\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}"],"names":[],"mappings":";;;;;;;IAqKsB,+BAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 241, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { createClient } from '@/utils/supabase/server'\r\nimport { revalidatePath } from 'next/cache'\r\nimport { SupabaseClient } from '@supabase/supabase-js'\r\n\r\nexport type ApprovalGroupNode = {\r\n  id: string;\r\n  group_name: string;\r\n  next_approver_group_id: string | null;\r\n  company_id: string;\r\n  is_final_authority: boolean;\r\n  role_count?: number; \r\n}\r\n\r\n// --- SECURITY HELPER ---\r\nasync function requireAuth(supabase: SupabaseClient) {\r\n  const { data: { user } } = await supabase.auth.getUser()\r\n  if (!user) throw new Error(\"Unauthorized\")\r\n\r\n  const { data: profile } = await supabase\r\n    .from('profiles')\r\n    .select('role:role_id(default_role_level)')\r\n    .eq('id', user.id)\r\n    .single()\r\n\r\n  const roleLevel = (profile?.role as any)?.default_role_level || 0\r\n  \r\n  if (roleLevel < 50) {\r\n    throw new Error(\"Insufficient permissions: You must be Staff to edit the Chain of Command.\")\r\n  }\r\n  \r\n  return user\r\n}\r\n\r\n// --- FETCHING ---\r\nexport async function getCompanyChain(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  const { data: companyGroups, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, group_name, next_approver_group_id, company_id, is_final_authority,\r\n      roles:roles(count)\r\n    `)\r\n    .eq('company_id', companyId)\r\n\r\n  if (error) {\r\n    console.error('Error fetching chain:', error)\r\n    return []\r\n  }\r\n\r\n  const formattedGroups = companyGroups.map(g => ({\r\n    ...g,\r\n    role_count: g.roles ? (g.roles as any)[0]?.count || 0 : 0\r\n  })) as ApprovalGroupNode[]\r\n\r\n  const outgoingLinkIds = formattedGroups\r\n    .map(g => g.next_approver_group_id)\r\n    .filter(id => id !== null) as string[];\r\n    \r\n  const existingIds = new Set(formattedGroups.map(g => g.id));\r\n  const missingIds = outgoingLinkIds.filter(id => !existingIds.has(id));\r\n\r\n  if (missingIds.length > 0) {\r\n    const { data: externalGroups } = await supabase\r\n      .from('approval_groups')\r\n      .select('id, group_name, next_approver_group_id, company_id, is_final_authority')\r\n      .in('id', missingIds);\r\n\r\n    if (externalGroups) {\r\n        formattedGroups.push(...(externalGroups as any[]));\r\n    }\r\n  }\r\n\r\n  return formattedGroups;\r\n}\r\n\r\nexport async function getGroupRoles(groupId: string) {\r\n  const supabase = createClient()\r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('approval_group_id', groupId)\r\n    .order('role_name')\r\n  \r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\nexport async function getAllApprovalGroups() {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e) { return [] }\r\n\r\n  const { data, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, \r\n      group_name, \r\n      company:company_id (company_name)\r\n    `)\r\n    .order('group_name')\r\n  \r\n  if (error) return []\r\n  \r\n  return data.map((g: any) => ({\r\n    id: g.id,\r\n    label: `${g.group_name} (${g.company?.company_name || 'No Co.'})`\r\n  }))\r\n}\r\n\r\n\r\n// --- MUTATIONS ---\r\n\r\nexport async function createGroupAction(\r\n  companyId: string, \r\n  groupName: string | null, \r\n  childGroupIdToApprove?: string | null,\r\n  existingGroupId?: string | null\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  let targetParentId = existingGroupId;\r\n\r\n  if (!targetParentId) {\r\n      if (!groupName) return { error: \"Group Name is required for new groups.\" };\r\n\r\n      let nextLink = null;\r\n      \r\n      if (childGroupIdToApprove) {\r\n          const { data: child } = await supabase.from('approval_groups').select('next_approver_group_id').eq('id', childGroupIdToApprove).single();\r\n          nextLink = child?.next_approver_group_id || null;\r\n      }\r\n\r\n      const { data: newGroup, error: createError } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: nextLink,\r\n          is_final_authority: !nextLink\r\n        })\r\n        .select('id')\r\n        .single();\r\n\r\n      if (createError) return { error: createError.message };\r\n      targetParentId = newGroup.id;\r\n  }\r\n\r\n  if (childGroupIdToApprove && targetParentId) {\r\n      const { error: updateError } = await supabase\r\n        .from('approval_groups')\r\n        .update({ \r\n            next_approver_group_id: targetParentId,\r\n            is_final_authority: false\r\n        })\r\n        .eq('id', childGroupIdToApprove);\r\n\r\n      if (updateError) return { error: \"Failed to re-link the chain.\" };\r\n  }\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function createSubordinateGroupAction(\r\n  companyId: string,\r\n  groupName: string | null,\r\n  parentGroupId: string,\r\n  existingGroupId?: string | null\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  if (existingGroupId) {\r\n      const { error } = await supabase\r\n        .from('approval_groups')\r\n        .update({ \r\n            next_approver_group_id: parentGroupId,\r\n            is_final_authority: false \r\n        })\r\n        .eq('id', existingGroupId);\r\n      \r\n      if (error) return { error: error.message };\r\n  } else {\r\n      if (!groupName) return { error: \"Name required.\" };\r\n      const { error } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: parentGroupId,\r\n          is_final_authority: false\r\n        });\r\n      if (error) return { error: error.message };\r\n  }\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function deleteGroupAction(groupId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { count } = await supabase\r\n    .from('roles')\r\n    .select('*', { count: 'exact', head: true })\r\n    .eq('approval_group_id', groupId)\r\n  \r\n  if (count && count > 0) {\r\n    return { error: \"Cannot delete: This group still contains roles. Please move or delete them first.\" }\r\n  }\r\n\r\n  const { data: targetGroup } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', groupId)\r\n    .single();\r\n  \r\n  if (!targetGroup) return { error: \"Group not found\" };\r\n  const parentId = targetGroup.next_approver_group_id;\r\n\r\n  const { error: relinkError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ \r\n        next_approver_group_id: parentId,\r\n        is_final_authority: (parentId === null) \r\n    })\r\n    .eq('next_approver_group_id', groupId);\r\n\r\n  if (relinkError) return { error: \"Failed to re-link children groups.\" };\r\n\r\n  const { error: deleteError } = await supabase\r\n    .from('approval_groups')\r\n    .delete()\r\n    .eq('id', groupId);\r\n\r\n  if (deleteError) return { error: deleteError.message };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n// --- NEW ROLE ASSIGNMENT ACTIONS ---\r\n\r\n// Action 1: Fetch Unassigned Roles for a Company\r\nexport async function getCompanyRoles(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // We want roles that are:\r\n  // 1. Belonging to this company\r\n  // 2. Not assigned to ANY approval group (approval_group_id IS NULL)\r\n  // OR roles that belong to this group (to show current) - but RoleListModal fetches current separately.\r\n  // So here we just want AVAILABLE roles.\r\n  \r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('company_id', companyId)\r\n    .is('approval_group_id', null)\r\n    .order('role_name')\r\n\r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\n// Action 2: Link Role to Group\r\nexport async function assignRoleToGroupAction(roleId: string, groupId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { error } = await supabase\r\n    .from('roles')\r\n    .update({ approval_group_id: groupId })\r\n    .eq('id', roleId)\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}\r\n\r\n// Action 3: Unlink Role from Group\r\nexport async function unassignRoleAction(roleId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { error } = await supabase\r\n    .from('roles')\r\n    .update({ approval_group_id: null })\r\n    .eq('id', roleId)\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}"],"names":[],"mappings":";;;;;;;IAyFsB,uBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 256, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/components/AddGroupModal.tsx"],"sourcesContent":["'use client'\r\nimport { useState, useEffect } from 'react'\r\nimport { createGroupAction, createSubordinateGroupAction, getAllApprovalGroups } from '../actions'\r\n\r\ninterface AddGroupModalProps {\r\n  isOpen: boolean\r\n  onClose: () => void\r\n  companyId: string\r\n  referenceGroupId: string | null\r\n  mode: 'genesis' | 'add_parent' | 'add_child' \r\n  onSuccess: () => void\r\n}\r\n\r\ntype GroupOption = { id: string; label: string }\r\n\r\nexport default function AddGroupModal({ isOpen, onClose, companyId, referenceGroupId, mode, onSuccess }: AddGroupModalProps) {\r\n  const [tab, setTab] = useState<'new' | 'existing'>('new')\r\n  const [name, setName] = useState('')\r\n  const [selectedGroupId, setSelectedGroupId] = useState('')\r\n  \r\n  const [options, setOptions] = useState<GroupOption[]>([])\r\n  const [loadingOptions, setLoadingOptions] = useState(false)\r\n  const [isSubmitting, setIsSubmitting] = useState(false)\r\n\r\n  // Fetch options on mount\r\n  useEffect(() => {\r\n    if (isOpen) {\r\n        setLoadingOptions(true)\r\n        getAllApprovalGroups().then(data => {\r\n            setOptions(data)\r\n            setLoadingOptions(false)\r\n        })\r\n    }\r\n  }, [isOpen])\r\n\r\n  const getTitle = () => {\r\n      switch(mode) {\r\n          case 'genesis': return 'Create First Group';\r\n          case 'add_parent': return 'Insert Next Approver';\r\n          case 'add_child': return 'Add Reporting Group';\r\n      }\r\n  }\r\n\r\n  const getDescription = () => {\r\n      switch(mode) {\r\n          case 'genesis': return 'Start the chain of command for this company.';\r\n          case 'add_parent': return 'This group will APPROVE reports from the selected group.';\r\n          case 'add_child': return 'This group will REPORT TO the selected group.';\r\n      }\r\n  }\r\n\r\n  const handleSubmit = async (e: React.FormEvent) => {\r\n    e.preventDefault()\r\n    if (tab === 'new' && !name.trim()) return\r\n    if (tab === 'existing' && !selectedGroupId) return\r\n    \r\n    setIsSubmitting(true)\r\n    let result;\r\n\r\n    const existingId = tab === 'existing' ? selectedGroupId : null;\r\n    const newName = tab === 'new' ? name : null;\r\n\r\n    if (mode === 'add_child' && referenceGroupId) {\r\n        // Add Subordinate\r\n        result = await createSubordinateGroupAction(companyId, newName, referenceGroupId, existingId)\r\n    } else {\r\n        // Add Parent (or Genesis)\r\n        result = await createGroupAction(companyId, newName, referenceGroupId, existingId)\r\n    }\r\n\r\n    setIsSubmitting(false)\r\n\r\n    if (result?.error) {\r\n      alert(result.error)\r\n    } else {\r\n      onSuccess()\r\n    }\r\n  }\r\n\r\n  if (!isOpen) return null\r\n\r\n  return (\r\n    <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm\">\r\n      <div className=\"bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl w-96 border dark:border-gray-700\">\r\n        <h2 className=\"text-lg font-bold mb-2 text-gray-900 dark:text-white\">\r\n            {getTitle()}\r\n        </h2>\r\n        <p className=\"text-sm text-gray-500 mb-4\">\r\n          {getDescription()}\r\n        </p>\r\n        \r\n        {/* TABS */}\r\n        <div className=\"flex border-b dark:border-gray-700 mb-4\">\r\n            <button \r\n                type=\"button\"\r\n                onClick={() => setTab('new')}\r\n                className={`flex-1 pb-2 text-sm font-medium ${tab === 'new' ? 'text-indigo-600 border-b-2 border-indigo-600' : 'text-gray-500'}`}\r\n            >\r\n                Create New\r\n            </button>\r\n            <button \r\n                type=\"button\"\r\n                onClick={() => setTab('existing')}\r\n                className={`flex-1 pb-2 text-sm font-medium ${tab === 'existing' ? 'text-indigo-600 border-b-2 border-indigo-600' : 'text-gray-500'}`}\r\n            >\r\n                Select Existing\r\n            </button>\r\n        </div>\r\n        \r\n        <form onSubmit={handleSubmit}>\r\n          \r\n          {tab === 'new' ? (\r\n              <div className=\"mb-4\">\r\n                <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">Group Name</label>\r\n                <input \r\n                  type=\"text\" \r\n                  value={name} \r\n                  onChange={e => setName(e.target.value)}\r\n                  placeholder={mode === 'genesis' ? \"e.g. Squad Leaders\" : \"e.g. Commandant\"}\r\n                  className=\"w-full rounded-md border-gray-300 dark:border-gray-600 dark:bg-gray-900 dark:text-white p-2\"\r\n                  autoFocus\r\n                />\r\n              </div>\r\n          ) : (\r\n              <div className=\"mb-4\">\r\n                <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">Select Group</label>\r\n                <select \r\n                    value={selectedGroupId}\r\n                    onChange={e => setSelectedGroupId(e.target.value)}\r\n                    className=\"w-full rounded-md border-gray-300 dark:border-gray-600 dark:bg-gray-900 dark:text-white p-2\"\r\n                    disabled={loadingOptions}\r\n                >\r\n                    <option value=\"\">-- Choose Group --</option>\r\n                    {options.map(opt => (\r\n                        <option key={opt.id} value={opt.id}>{opt.label}</option>\r\n                    ))}\r\n                </select>\r\n                {loadingOptions && <p className=\"text-xs text-gray-500 mt-1\">Loading list...</p>}\r\n              </div>\r\n          )}\r\n\r\n          <div className=\"flex justify-end gap-2\">\r\n            <button type=\"button\" onClick={onClose} className=\"px-3 py-1.5 text-sm text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded\">Cancel</button>\r\n            <button \r\n              type=\"submit\" \r\n              disabled={isSubmitting || (tab === 'new' ? !name.trim() : !selectedGroupId)}\r\n              className=\"px-3 py-1.5 text-sm bg-indigo-600 text-white rounded hover:bg-indigo-700 disabled:opacity-50\"\r\n            >\r\n              {isSubmitting ? 'Saving...' : (tab === 'new' ? 'Create' : 'Link Group')}\r\n            </button>\r\n          </div>\r\n        </form>\r\n      </div>\r\n    </div>\r\n  )\r\n}"],"names":[],"mappings":";;;;;AACA;AACA;AAAA;AAAA;;;AAFA;;;AAee,SAAS,cAAc,EAAE,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,gBAAgB,EAAE,IAAI,EAAE,SAAS,EAAsB;;IACzH,MAAM,CAAC,KAAK,OAAO,GAAG,IAAA,yKAAQ,EAAqB;IACnD,MAAM,CAAC,MAAM,QAAQ,GAAG,IAAA,yKAAQ,EAAC;IACjC,MAAM,CAAC,iBAAiB,mBAAmB,GAAG,IAAA,yKAAQ,EAAC;IAEvD,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,yKAAQ,EAAgB,EAAE;IACxD,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,IAAA,yKAAQ,EAAC;IACrD,MAAM,CAAC,cAAc,gBAAgB,GAAG,IAAA,yKAAQ,EAAC;IAEjD,yBAAyB;IACzB,IAAA,0KAAS;mCAAC;YACR,IAAI,QAAQ;gBACR,kBAAkB;gBAClB,IAAA,yLAAoB,IAAG,IAAI;+CAAC,CAAA;wBACxB,WAAW;wBACX,kBAAkB;oBACtB;;YACJ;QACF;kCAAG;QAAC;KAAO;IAEX,MAAM,WAAW;QACb,OAAO;YACH,KAAK;gBAAW,OAAO;YACvB,KAAK;gBAAc,OAAO;YAC1B,KAAK;gBAAa,OAAO;QAC7B;IACJ;IAEA,MAAM,iBAAiB;QACnB,OAAO;YACH,KAAK;gBAAW,OAAO;YACvB,KAAK;gBAAc,OAAO;YAC1B,KAAK;gBAAa,OAAO;QAC7B;IACJ;IAEA,MAAM,eAAe,OAAO;QAC1B,EAAE,cAAc;QAChB,IAAI,QAAQ,SAAS,CAAC,KAAK,IAAI,IAAI;QACnC,IAAI,QAAQ,cAAc,CAAC,iBAAiB;QAE5C,gBAAgB;QAChB,IAAI;QAEJ,MAAM,aAAa,QAAQ,aAAa,kBAAkB;QAC1D,MAAM,UAAU,QAAQ,QAAQ,OAAO;QAEvC,IAAI,SAAS,eAAe,kBAAkB;YAC1C,kBAAkB;YAClB,SAAS,MAAM,IAAA,iMAA4B,EAAC,WAAW,SAAS,kBAAkB;QACtF,OAAO;YACH,0BAA0B;YAC1B,SAAS,MAAM,IAAA,sLAAiB,EAAC,WAAW,SAAS,kBAAkB;QAC3E;QAEA,gBAAgB;QAEhB,IAAI,QAAQ,OAAO;YACjB,MAAM,OAAO,KAAK;QACpB,OAAO;YACL;QACF;IACF;IAEA,IAAI,CAAC,QAAQ,OAAO;IAEpB,qBACE,6LAAC;QAAI,WAAU;kBACb,cAAA,6LAAC;YAAI,WAAU;;8BACb,6LAAC;oBAAG,WAAU;8BACT;;;;;;8BAEL,6LAAC;oBAAE,WAAU;8BACV;;;;;;8BAIH,6LAAC;oBAAI,WAAU;;sCACX,6LAAC;4BACG,MAAK;4BACL,SAAS,IAAM,OAAO;4BACtB,WAAW,CAAC,gCAAgC,EAAE,QAAQ,QAAQ,iDAAiD,iBAAiB;sCACnI;;;;;;sCAGD,6LAAC;4BACG,MAAK;4BACL,SAAS,IAAM,OAAO;4BACtB,WAAW,CAAC,gCAAgC,EAAE,QAAQ,aAAa,iDAAiD,iBAAiB;sCACxI;;;;;;;;;;;;8BAKL,6LAAC;oBAAK,UAAU;;wBAEb,QAAQ,sBACL,6LAAC;4BAAI,WAAU;;8CACb,6LAAC;oCAAM,WAAU;8CAAkE;;;;;;8CACnF,6LAAC;oCACC,MAAK;oCACL,OAAO;oCACP,UAAU,CAAA,IAAK,QAAQ,EAAE,MAAM,CAAC,KAAK;oCACrC,aAAa,SAAS,YAAY,uBAAuB;oCACzD,WAAU;oCACV,SAAS;;;;;;;;;;;iDAIb,6LAAC;4BAAI,WAAU;;8CACb,6LAAC;oCAAM,WAAU;8CAAkE;;;;;;8CACnF,6LAAC;oCACG,OAAO;oCACP,UAAU,CAAA,IAAK,mBAAmB,EAAE,MAAM,CAAC,KAAK;oCAChD,WAAU;oCACV,UAAU;;sDAEV,6LAAC;4CAAO,OAAM;sDAAG;;;;;;wCAChB,QAAQ,GAAG,CAAC,CAAA,oBACT,6LAAC;gDAAoB,OAAO,IAAI,EAAE;0DAAG,IAAI,KAAK;+CAAjC,IAAI,EAAE;;;;;;;;;;;gCAG1B,gCAAkB,6LAAC;oCAAE,WAAU;8CAA6B;;;;;;;;;;;;sCAInE,6LAAC;4BAAI,WAAU;;8CACb,6LAAC;oCAAO,MAAK;oCAAS,SAAS;oCAAS,WAAU;8CAAwG;;;;;;8CAC1J,6LAAC;oCACC,MAAK;oCACL,UAAU,gBAAgB,CAAC,QAAQ,QAAQ,CAAC,KAAK,IAAI,KAAK,CAAC,eAAe;oCAC1E,WAAU;8CAET,eAAe,cAAe,QAAQ,QAAQ,WAAW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOxE;GA5IwB;KAAA","debugId":null}},
    {"offset": {"line": 529, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { createClient } from '@/utils/supabase/server'\r\nimport { revalidatePath } from 'next/cache'\r\nimport { SupabaseClient } from '@supabase/supabase-js'\r\n\r\nexport type ApprovalGroupNode = {\r\n  id: string;\r\n  group_name: string;\r\n  next_approver_group_id: string | null;\r\n  company_id: string;\r\n  is_final_authority: boolean;\r\n  role_count?: number; \r\n}\r\n\r\n// --- SECURITY HELPER ---\r\nasync function requireAuth(supabase: SupabaseClient) {\r\n  const { data: { user } } = await supabase.auth.getUser()\r\n  if (!user) throw new Error(\"Unauthorized\")\r\n\r\n  const { data: profile } = await supabase\r\n    .from('profiles')\r\n    .select('role:role_id(default_role_level)')\r\n    .eq('id', user.id)\r\n    .single()\r\n\r\n  const roleLevel = (profile?.role as any)?.default_role_level || 0\r\n  \r\n  if (roleLevel < 50) {\r\n    throw new Error(\"Insufficient permissions: You must be Staff to edit the Chain of Command.\")\r\n  }\r\n  \r\n  return user\r\n}\r\n\r\n// --- FETCHING ---\r\nexport async function getCompanyChain(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  const { data: companyGroups, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, group_name, next_approver_group_id, company_id, is_final_authority,\r\n      roles:roles(count)\r\n    `)\r\n    .eq('company_id', companyId)\r\n\r\n  if (error) {\r\n    console.error('Error fetching chain:', error)\r\n    return []\r\n  }\r\n\r\n  const formattedGroups = companyGroups.map(g => ({\r\n    ...g,\r\n    role_count: g.roles ? (g.roles as any)[0]?.count || 0 : 0\r\n  })) as ApprovalGroupNode[]\r\n\r\n  const outgoingLinkIds = formattedGroups\r\n    .map(g => g.next_approver_group_id)\r\n    .filter(id => id !== null) as string[];\r\n    \r\n  const existingIds = new Set(formattedGroups.map(g => g.id));\r\n  const missingIds = outgoingLinkIds.filter(id => !existingIds.has(id));\r\n\r\n  if (missingIds.length > 0) {\r\n    const { data: externalGroups } = await supabase\r\n      .from('approval_groups')\r\n      .select('id, group_name, next_approver_group_id, company_id, is_final_authority')\r\n      .in('id', missingIds);\r\n\r\n    if (externalGroups) {\r\n        formattedGroups.push(...(externalGroups as any[]));\r\n    }\r\n  }\r\n\r\n  return formattedGroups;\r\n}\r\n\r\nexport async function getGroupRoles(groupId: string) {\r\n  const supabase = createClient()\r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('approval_group_id', groupId)\r\n    .order('role_name')\r\n  \r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\nexport async function getAllApprovalGroups() {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e) { return [] }\r\n\r\n  const { data, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, \r\n      group_name, \r\n      company:company_id (company_name)\r\n    `)\r\n    .order('group_name')\r\n  \r\n  if (error) return []\r\n  \r\n  return data.map((g: any) => ({\r\n    id: g.id,\r\n    label: `${g.group_name} (${g.company?.company_name || 'No Co.'})`\r\n  }))\r\n}\r\n\r\n\r\n// --- MUTATIONS ---\r\n\r\nexport async function createGroupAction(\r\n  companyId: string, \r\n  groupName: string | null, \r\n  childGroupIdToApprove?: string | null,\r\n  existingGroupId?: string | null\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  let targetParentId = existingGroupId;\r\n\r\n  if (!targetParentId) {\r\n      if (!groupName) return { error: \"Group Name is required for new groups.\" };\r\n\r\n      let nextLink = null;\r\n      \r\n      if (childGroupIdToApprove) {\r\n          const { data: child } = await supabase.from('approval_groups').select('next_approver_group_id').eq('id', childGroupIdToApprove).single();\r\n          nextLink = child?.next_approver_group_id || null;\r\n      }\r\n\r\n      const { data: newGroup, error: createError } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: nextLink,\r\n          is_final_authority: !nextLink\r\n        })\r\n        .select('id')\r\n        .single();\r\n\r\n      if (createError) return { error: createError.message };\r\n      targetParentId = newGroup.id;\r\n  }\r\n\r\n  if (childGroupIdToApprove && targetParentId) {\r\n      const { error: updateError } = await supabase\r\n        .from('approval_groups')\r\n        .update({ \r\n            next_approver_group_id: targetParentId,\r\n            is_final_authority: false\r\n        })\r\n        .eq('id', childGroupIdToApprove);\r\n\r\n      if (updateError) return { error: \"Failed to re-link the chain.\" };\r\n  }\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function createSubordinateGroupAction(\r\n  companyId: string,\r\n  groupName: string | null,\r\n  parentGroupId: string,\r\n  existingGroupId?: string | null\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  if (existingGroupId) {\r\n      const { error } = await supabase\r\n        .from('approval_groups')\r\n        .update({ \r\n            next_approver_group_id: parentGroupId,\r\n            is_final_authority: false \r\n        })\r\n        .eq('id', existingGroupId);\r\n      \r\n      if (error) return { error: error.message };\r\n  } else {\r\n      if (!groupName) return { error: \"Name required.\" };\r\n      const { error } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: parentGroupId,\r\n          is_final_authority: false\r\n        });\r\n      if (error) return { error: error.message };\r\n  }\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function deleteGroupAction(groupId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { count } = await supabase\r\n    .from('roles')\r\n    .select('*', { count: 'exact', head: true })\r\n    .eq('approval_group_id', groupId)\r\n  \r\n  if (count && count > 0) {\r\n    return { error: \"Cannot delete: This group still contains roles. Please move or delete them first.\" }\r\n  }\r\n\r\n  const { data: targetGroup } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', groupId)\r\n    .single();\r\n  \r\n  if (!targetGroup) return { error: \"Group not found\" };\r\n  const parentId = targetGroup.next_approver_group_id;\r\n\r\n  const { error: relinkError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ \r\n        next_approver_group_id: parentId,\r\n        is_final_authority: (parentId === null) \r\n    })\r\n    .eq('next_approver_group_id', groupId);\r\n\r\n  if (relinkError) return { error: \"Failed to re-link children groups.\" };\r\n\r\n  const { error: deleteError } = await supabase\r\n    .from('approval_groups')\r\n    .delete()\r\n    .eq('id', groupId);\r\n\r\n  if (deleteError) return { error: deleteError.message };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n// --- NEW ROLE ASSIGNMENT ACTIONS ---\r\n\r\n// Action 1: Fetch Unassigned Roles for a Company\r\nexport async function getCompanyRoles(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // We want roles that are:\r\n  // 1. Belonging to this company\r\n  // 2. Not assigned to ANY approval group (approval_group_id IS NULL)\r\n  // OR roles that belong to this group (to show current) - but RoleListModal fetches current separately.\r\n  // So here we just want AVAILABLE roles.\r\n  \r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('company_id', companyId)\r\n    .is('approval_group_id', null)\r\n    .order('role_name')\r\n\r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\n// Action 2: Link Role to Group\r\nexport async function assignRoleToGroupAction(roleId: string, groupId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { error } = await supabase\r\n    .from('roles')\r\n    .update({ approval_group_id: groupId })\r\n    .eq('id', roleId)\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}\r\n\r\n// Action 3: Unlink Role from Group\r\nexport async function unassignRoleAction(roleId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { error } = await supabase\r\n    .from('roles')\r\n    .update({ approval_group_id: null })\r\n    .eq('id', roleId)\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}"],"names":[],"mappings":";;;;;;;IA8EsB,gBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 544, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { createClient } from '@/utils/supabase/server'\r\nimport { revalidatePath } from 'next/cache'\r\nimport { SupabaseClient } from '@supabase/supabase-js'\r\n\r\nexport type ApprovalGroupNode = {\r\n  id: string;\r\n  group_name: string;\r\n  next_approver_group_id: string | null;\r\n  company_id: string;\r\n  is_final_authority: boolean;\r\n  role_count?: number; \r\n}\r\n\r\n// --- SECURITY HELPER ---\r\nasync function requireAuth(supabase: SupabaseClient) {\r\n  const { data: { user } } = await supabase.auth.getUser()\r\n  if (!user) throw new Error(\"Unauthorized\")\r\n\r\n  const { data: profile } = await supabase\r\n    .from('profiles')\r\n    .select('role:role_id(default_role_level)')\r\n    .eq('id', user.id)\r\n    .single()\r\n\r\n  const roleLevel = (profile?.role as any)?.default_role_level || 0\r\n  \r\n  if (roleLevel < 50) {\r\n    throw new Error(\"Insufficient permissions: You must be Staff to edit the Chain of Command.\")\r\n  }\r\n  \r\n  return user\r\n}\r\n\r\n// --- FETCHING ---\r\nexport async function getCompanyChain(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  const { data: companyGroups, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, group_name, next_approver_group_id, company_id, is_final_authority,\r\n      roles:roles(count)\r\n    `)\r\n    .eq('company_id', companyId)\r\n\r\n  if (error) {\r\n    console.error('Error fetching chain:', error)\r\n    return []\r\n  }\r\n\r\n  const formattedGroups = companyGroups.map(g => ({\r\n    ...g,\r\n    role_count: g.roles ? (g.roles as any)[0]?.count || 0 : 0\r\n  })) as ApprovalGroupNode[]\r\n\r\n  const outgoingLinkIds = formattedGroups\r\n    .map(g => g.next_approver_group_id)\r\n    .filter(id => id !== null) as string[];\r\n    \r\n  const existingIds = new Set(formattedGroups.map(g => g.id));\r\n  const missingIds = outgoingLinkIds.filter(id => !existingIds.has(id));\r\n\r\n  if (missingIds.length > 0) {\r\n    const { data: externalGroups } = await supabase\r\n      .from('approval_groups')\r\n      .select('id, group_name, next_approver_group_id, company_id, is_final_authority')\r\n      .in('id', missingIds);\r\n\r\n    if (externalGroups) {\r\n        formattedGroups.push(...(externalGroups as any[]));\r\n    }\r\n  }\r\n\r\n  return formattedGroups;\r\n}\r\n\r\nexport async function getGroupRoles(groupId: string) {\r\n  const supabase = createClient()\r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('approval_group_id', groupId)\r\n    .order('role_name')\r\n  \r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\nexport async function getAllApprovalGroups() {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e) { return [] }\r\n\r\n  const { data, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, \r\n      group_name, \r\n      company:company_id (company_name)\r\n    `)\r\n    .order('group_name')\r\n  \r\n  if (error) return []\r\n  \r\n  return data.map((g: any) => ({\r\n    id: g.id,\r\n    label: `${g.group_name} (${g.company?.company_name || 'No Co.'})`\r\n  }))\r\n}\r\n\r\n\r\n// --- MUTATIONS ---\r\n\r\nexport async function createGroupAction(\r\n  companyId: string, \r\n  groupName: string | null, \r\n  childGroupIdToApprove?: string | null,\r\n  existingGroupId?: string | null\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  let targetParentId = existingGroupId;\r\n\r\n  if (!targetParentId) {\r\n      if (!groupName) return { error: \"Group Name is required for new groups.\" };\r\n\r\n      let nextLink = null;\r\n      \r\n      if (childGroupIdToApprove) {\r\n          const { data: child } = await supabase.from('approval_groups').select('next_approver_group_id').eq('id', childGroupIdToApprove).single();\r\n          nextLink = child?.next_approver_group_id || null;\r\n      }\r\n\r\n      const { data: newGroup, error: createError } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: nextLink,\r\n          is_final_authority: !nextLink\r\n        })\r\n        .select('id')\r\n        .single();\r\n\r\n      if (createError) return { error: createError.message };\r\n      targetParentId = newGroup.id;\r\n  }\r\n\r\n  if (childGroupIdToApprove && targetParentId) {\r\n      const { error: updateError } = await supabase\r\n        .from('approval_groups')\r\n        .update({ \r\n            next_approver_group_id: targetParentId,\r\n            is_final_authority: false\r\n        })\r\n        .eq('id', childGroupIdToApprove);\r\n\r\n      if (updateError) return { error: \"Failed to re-link the chain.\" };\r\n  }\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function createSubordinateGroupAction(\r\n  companyId: string,\r\n  groupName: string | null,\r\n  parentGroupId: string,\r\n  existingGroupId?: string | null\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  if (existingGroupId) {\r\n      const { error } = await supabase\r\n        .from('approval_groups')\r\n        .update({ \r\n            next_approver_group_id: parentGroupId,\r\n            is_final_authority: false \r\n        })\r\n        .eq('id', existingGroupId);\r\n      \r\n      if (error) return { error: error.message };\r\n  } else {\r\n      if (!groupName) return { error: \"Name required.\" };\r\n      const { error } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: parentGroupId,\r\n          is_final_authority: false\r\n        });\r\n      if (error) return { error: error.message };\r\n  }\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function deleteGroupAction(groupId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { count } = await supabase\r\n    .from('roles')\r\n    .select('*', { count: 'exact', head: true })\r\n    .eq('approval_group_id', groupId)\r\n  \r\n  if (count && count > 0) {\r\n    return { error: \"Cannot delete: This group still contains roles. Please move or delete them first.\" }\r\n  }\r\n\r\n  const { data: targetGroup } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', groupId)\r\n    .single();\r\n  \r\n  if (!targetGroup) return { error: \"Group not found\" };\r\n  const parentId = targetGroup.next_approver_group_id;\r\n\r\n  const { error: relinkError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ \r\n        next_approver_group_id: parentId,\r\n        is_final_authority: (parentId === null) \r\n    })\r\n    .eq('next_approver_group_id', groupId);\r\n\r\n  if (relinkError) return { error: \"Failed to re-link children groups.\" };\r\n\r\n  const { error: deleteError } = await supabase\r\n    .from('approval_groups')\r\n    .delete()\r\n    .eq('id', groupId);\r\n\r\n  if (deleteError) return { error: deleteError.message };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n// --- NEW ROLE ASSIGNMENT ACTIONS ---\r\n\r\n// Action 1: Fetch Unassigned Roles for a Company\r\nexport async function getCompanyRoles(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // We want roles that are:\r\n  // 1. Belonging to this company\r\n  // 2. Not assigned to ANY approval group (approval_group_id IS NULL)\r\n  // OR roles that belong to this group (to show current) - but RoleListModal fetches current separately.\r\n  // So here we just want AVAILABLE roles.\r\n  \r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('company_id', companyId)\r\n    .is('approval_group_id', null)\r\n    .order('role_name')\r\n\r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\n// Action 2: Link Role to Group\r\nexport async function assignRoleToGroupAction(roleId: string, groupId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { error } = await supabase\r\n    .from('roles')\r\n    .update({ approval_group_id: groupId })\r\n    .eq('id', roleId)\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}\r\n\r\n// Action 3: Unlink Role from Group\r\nexport async function unassignRoleAction(roleId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { error } = await supabase\r\n    .from('roles')\r\n    .update({ approval_group_id: null })\r\n    .eq('id', roleId)\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}"],"names":[],"mappings":";;;;;;;IAuPsB,kBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 559, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { createClient } from '@/utils/supabase/server'\r\nimport { revalidatePath } from 'next/cache'\r\nimport { SupabaseClient } from '@supabase/supabase-js'\r\n\r\nexport type ApprovalGroupNode = {\r\n  id: string;\r\n  group_name: string;\r\n  next_approver_group_id: string | null;\r\n  company_id: string;\r\n  is_final_authority: boolean;\r\n  role_count?: number; \r\n}\r\n\r\n// --- SECURITY HELPER ---\r\nasync function requireAuth(supabase: SupabaseClient) {\r\n  const { data: { user } } = await supabase.auth.getUser()\r\n  if (!user) throw new Error(\"Unauthorized\")\r\n\r\n  const { data: profile } = await supabase\r\n    .from('profiles')\r\n    .select('role:role_id(default_role_level)')\r\n    .eq('id', user.id)\r\n    .single()\r\n\r\n  const roleLevel = (profile?.role as any)?.default_role_level || 0\r\n  \r\n  if (roleLevel < 50) {\r\n    throw new Error(\"Insufficient permissions: You must be Staff to edit the Chain of Command.\")\r\n  }\r\n  \r\n  return user\r\n}\r\n\r\n// --- FETCHING ---\r\nexport async function getCompanyChain(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  const { data: companyGroups, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, group_name, next_approver_group_id, company_id, is_final_authority,\r\n      roles:roles(count)\r\n    `)\r\n    .eq('company_id', companyId)\r\n\r\n  if (error) {\r\n    console.error('Error fetching chain:', error)\r\n    return []\r\n  }\r\n\r\n  const formattedGroups = companyGroups.map(g => ({\r\n    ...g,\r\n    role_count: g.roles ? (g.roles as any)[0]?.count || 0 : 0\r\n  })) as ApprovalGroupNode[]\r\n\r\n  const outgoingLinkIds = formattedGroups\r\n    .map(g => g.next_approver_group_id)\r\n    .filter(id => id !== null) as string[];\r\n    \r\n  const existingIds = new Set(formattedGroups.map(g => g.id));\r\n  const missingIds = outgoingLinkIds.filter(id => !existingIds.has(id));\r\n\r\n  if (missingIds.length > 0) {\r\n    const { data: externalGroups } = await supabase\r\n      .from('approval_groups')\r\n      .select('id, group_name, next_approver_group_id, company_id, is_final_authority')\r\n      .in('id', missingIds);\r\n\r\n    if (externalGroups) {\r\n        formattedGroups.push(...(externalGroups as any[]));\r\n    }\r\n  }\r\n\r\n  return formattedGroups;\r\n}\r\n\r\nexport async function getGroupRoles(groupId: string) {\r\n  const supabase = createClient()\r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('approval_group_id', groupId)\r\n    .order('role_name')\r\n  \r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\nexport async function getAllApprovalGroups() {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e) { return [] }\r\n\r\n  const { data, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, \r\n      group_name, \r\n      company:company_id (company_name)\r\n    `)\r\n    .order('group_name')\r\n  \r\n  if (error) return []\r\n  \r\n  return data.map((g: any) => ({\r\n    id: g.id,\r\n    label: `${g.group_name} (${g.company?.company_name || 'No Co.'})`\r\n  }))\r\n}\r\n\r\n\r\n// --- MUTATIONS ---\r\n\r\nexport async function createGroupAction(\r\n  companyId: string, \r\n  groupName: string | null, \r\n  childGroupIdToApprove?: string | null,\r\n  existingGroupId?: string | null\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  let targetParentId = existingGroupId;\r\n\r\n  if (!targetParentId) {\r\n      if (!groupName) return { error: \"Group Name is required for new groups.\" };\r\n\r\n      let nextLink = null;\r\n      \r\n      if (childGroupIdToApprove) {\r\n          const { data: child } = await supabase.from('approval_groups').select('next_approver_group_id').eq('id', childGroupIdToApprove).single();\r\n          nextLink = child?.next_approver_group_id || null;\r\n      }\r\n\r\n      const { data: newGroup, error: createError } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: nextLink,\r\n          is_final_authority: !nextLink\r\n        })\r\n        .select('id')\r\n        .single();\r\n\r\n      if (createError) return { error: createError.message };\r\n      targetParentId = newGroup.id;\r\n  }\r\n\r\n  if (childGroupIdToApprove && targetParentId) {\r\n      const { error: updateError } = await supabase\r\n        .from('approval_groups')\r\n        .update({ \r\n            next_approver_group_id: targetParentId,\r\n            is_final_authority: false\r\n        })\r\n        .eq('id', childGroupIdToApprove);\r\n\r\n      if (updateError) return { error: \"Failed to re-link the chain.\" };\r\n  }\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function createSubordinateGroupAction(\r\n  companyId: string,\r\n  groupName: string | null,\r\n  parentGroupId: string,\r\n  existingGroupId?: string | null\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  if (existingGroupId) {\r\n      const { error } = await supabase\r\n        .from('approval_groups')\r\n        .update({ \r\n            next_approver_group_id: parentGroupId,\r\n            is_final_authority: false \r\n        })\r\n        .eq('id', existingGroupId);\r\n      \r\n      if (error) return { error: error.message };\r\n  } else {\r\n      if (!groupName) return { error: \"Name required.\" };\r\n      const { error } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: parentGroupId,\r\n          is_final_authority: false\r\n        });\r\n      if (error) return { error: error.message };\r\n  }\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function deleteGroupAction(groupId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { count } = await supabase\r\n    .from('roles')\r\n    .select('*', { count: 'exact', head: true })\r\n    .eq('approval_group_id', groupId)\r\n  \r\n  if (count && count > 0) {\r\n    return { error: \"Cannot delete: This group still contains roles. Please move or delete them first.\" }\r\n  }\r\n\r\n  const { data: targetGroup } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', groupId)\r\n    .single();\r\n  \r\n  if (!targetGroup) return { error: \"Group not found\" };\r\n  const parentId = targetGroup.next_approver_group_id;\r\n\r\n  const { error: relinkError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ \r\n        next_approver_group_id: parentId,\r\n        is_final_authority: (parentId === null) \r\n    })\r\n    .eq('next_approver_group_id', groupId);\r\n\r\n  if (relinkError) return { error: \"Failed to re-link children groups.\" };\r\n\r\n  const { error: deleteError } = await supabase\r\n    .from('approval_groups')\r\n    .delete()\r\n    .eq('id', groupId);\r\n\r\n  if (deleteError) return { error: deleteError.message };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n// --- NEW ROLE ASSIGNMENT ACTIONS ---\r\n\r\n// Action 1: Fetch Unassigned Roles for a Company\r\nexport async function getCompanyRoles(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // We want roles that are:\r\n  // 1. Belonging to this company\r\n  // 2. Not assigned to ANY approval group (approval_group_id IS NULL)\r\n  // OR roles that belong to this group (to show current) - but RoleListModal fetches current separately.\r\n  // So here we just want AVAILABLE roles.\r\n  \r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('company_id', companyId)\r\n    .is('approval_group_id', null)\r\n    .order('role_name')\r\n\r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\n// Action 2: Link Role to Group\r\nexport async function assignRoleToGroupAction(roleId: string, groupId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { error } = await supabase\r\n    .from('roles')\r\n    .update({ approval_group_id: groupId })\r\n    .eq('id', roleId)\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}\r\n\r\n// Action 3: Unlink Role from Group\r\nexport async function unassignRoleAction(roleId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { error } = await supabase\r\n    .from('roles')\r\n    .update({ approval_group_id: null })\r\n    .eq('id', roleId)\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}"],"names":[],"mappings":";;;;;;;IA2QsB,0BAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 574, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { createClient } from '@/utils/supabase/server'\r\nimport { revalidatePath } from 'next/cache'\r\nimport { SupabaseClient } from '@supabase/supabase-js'\r\n\r\nexport type ApprovalGroupNode = {\r\n  id: string;\r\n  group_name: string;\r\n  next_approver_group_id: string | null;\r\n  company_id: string;\r\n  is_final_authority: boolean;\r\n  role_count?: number; \r\n}\r\n\r\n// --- SECURITY HELPER ---\r\nasync function requireAuth(supabase: SupabaseClient) {\r\n  const { data: { user } } = await supabase.auth.getUser()\r\n  if (!user) throw new Error(\"Unauthorized\")\r\n\r\n  const { data: profile } = await supabase\r\n    .from('profiles')\r\n    .select('role:role_id(default_role_level)')\r\n    .eq('id', user.id)\r\n    .single()\r\n\r\n  const roleLevel = (profile?.role as any)?.default_role_level || 0\r\n  \r\n  if (roleLevel < 50) {\r\n    throw new Error(\"Insufficient permissions: You must be Staff to edit the Chain of Command.\")\r\n  }\r\n  \r\n  return user\r\n}\r\n\r\n// --- FETCHING ---\r\nexport async function getCompanyChain(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  const { data: companyGroups, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, group_name, next_approver_group_id, company_id, is_final_authority,\r\n      roles:roles(count)\r\n    `)\r\n    .eq('company_id', companyId)\r\n\r\n  if (error) {\r\n    console.error('Error fetching chain:', error)\r\n    return []\r\n  }\r\n\r\n  const formattedGroups = companyGroups.map(g => ({\r\n    ...g,\r\n    role_count: g.roles ? (g.roles as any)[0]?.count || 0 : 0\r\n  })) as ApprovalGroupNode[]\r\n\r\n  const outgoingLinkIds = formattedGroups\r\n    .map(g => g.next_approver_group_id)\r\n    .filter(id => id !== null) as string[];\r\n    \r\n  const existingIds = new Set(formattedGroups.map(g => g.id));\r\n  const missingIds = outgoingLinkIds.filter(id => !existingIds.has(id));\r\n\r\n  if (missingIds.length > 0) {\r\n    const { data: externalGroups } = await supabase\r\n      .from('approval_groups')\r\n      .select('id, group_name, next_approver_group_id, company_id, is_final_authority')\r\n      .in('id', missingIds);\r\n\r\n    if (externalGroups) {\r\n        formattedGroups.push(...(externalGroups as any[]));\r\n    }\r\n  }\r\n\r\n  return formattedGroups;\r\n}\r\n\r\nexport async function getGroupRoles(groupId: string) {\r\n  const supabase = createClient()\r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('approval_group_id', groupId)\r\n    .order('role_name')\r\n  \r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\nexport async function getAllApprovalGroups() {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e) { return [] }\r\n\r\n  const { data, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, \r\n      group_name, \r\n      company:company_id (company_name)\r\n    `)\r\n    .order('group_name')\r\n  \r\n  if (error) return []\r\n  \r\n  return data.map((g: any) => ({\r\n    id: g.id,\r\n    label: `${g.group_name} (${g.company?.company_name || 'No Co.'})`\r\n  }))\r\n}\r\n\r\n\r\n// --- MUTATIONS ---\r\n\r\nexport async function createGroupAction(\r\n  companyId: string, \r\n  groupName: string | null, \r\n  childGroupIdToApprove?: string | null,\r\n  existingGroupId?: string | null\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  let targetParentId = existingGroupId;\r\n\r\n  if (!targetParentId) {\r\n      if (!groupName) return { error: \"Group Name is required for new groups.\" };\r\n\r\n      let nextLink = null;\r\n      \r\n      if (childGroupIdToApprove) {\r\n          const { data: child } = await supabase.from('approval_groups').select('next_approver_group_id').eq('id', childGroupIdToApprove).single();\r\n          nextLink = child?.next_approver_group_id || null;\r\n      }\r\n\r\n      const { data: newGroup, error: createError } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: nextLink,\r\n          is_final_authority: !nextLink\r\n        })\r\n        .select('id')\r\n        .single();\r\n\r\n      if (createError) return { error: createError.message };\r\n      targetParentId = newGroup.id;\r\n  }\r\n\r\n  if (childGroupIdToApprove && targetParentId) {\r\n      const { error: updateError } = await supabase\r\n        .from('approval_groups')\r\n        .update({ \r\n            next_approver_group_id: targetParentId,\r\n            is_final_authority: false\r\n        })\r\n        .eq('id', childGroupIdToApprove);\r\n\r\n      if (updateError) return { error: \"Failed to re-link the chain.\" };\r\n  }\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function createSubordinateGroupAction(\r\n  companyId: string,\r\n  groupName: string | null,\r\n  parentGroupId: string,\r\n  existingGroupId?: string | null\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  if (existingGroupId) {\r\n      const { error } = await supabase\r\n        .from('approval_groups')\r\n        .update({ \r\n            next_approver_group_id: parentGroupId,\r\n            is_final_authority: false \r\n        })\r\n        .eq('id', existingGroupId);\r\n      \r\n      if (error) return { error: error.message };\r\n  } else {\r\n      if (!groupName) return { error: \"Name required.\" };\r\n      const { error } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: parentGroupId,\r\n          is_final_authority: false\r\n        });\r\n      if (error) return { error: error.message };\r\n  }\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function deleteGroupAction(groupId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { count } = await supabase\r\n    .from('roles')\r\n    .select('*', { count: 'exact', head: true })\r\n    .eq('approval_group_id', groupId)\r\n  \r\n  if (count && count > 0) {\r\n    return { error: \"Cannot delete: This group still contains roles. Please move or delete them first.\" }\r\n  }\r\n\r\n  const { data: targetGroup } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', groupId)\r\n    .single();\r\n  \r\n  if (!targetGroup) return { error: \"Group not found\" };\r\n  const parentId = targetGroup.next_approver_group_id;\r\n\r\n  const { error: relinkError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ \r\n        next_approver_group_id: parentId,\r\n        is_final_authority: (parentId === null) \r\n    })\r\n    .eq('next_approver_group_id', groupId);\r\n\r\n  if (relinkError) return { error: \"Failed to re-link children groups.\" };\r\n\r\n  const { error: deleteError } = await supabase\r\n    .from('approval_groups')\r\n    .delete()\r\n    .eq('id', groupId);\r\n\r\n  if (deleteError) return { error: deleteError.message };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n// --- NEW ROLE ASSIGNMENT ACTIONS ---\r\n\r\n// Action 1: Fetch Unassigned Roles for a Company\r\nexport async function getCompanyRoles(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // We want roles that are:\r\n  // 1. Belonging to this company\r\n  // 2. Not assigned to ANY approval group (approval_group_id IS NULL)\r\n  // OR roles that belong to this group (to show current) - but RoleListModal fetches current separately.\r\n  // So here we just want AVAILABLE roles.\r\n  \r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('company_id', companyId)\r\n    .is('approval_group_id', null)\r\n    .order('role_name')\r\n\r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\n// Action 2: Link Role to Group\r\nexport async function assignRoleToGroupAction(roleId: string, groupId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { error } = await supabase\r\n    .from('roles')\r\n    .update({ approval_group_id: groupId })\r\n    .eq('id', roleId)\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}\r\n\r\n// Action 3: Unlink Role from Group\r\nexport async function unassignRoleAction(roleId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { error } = await supabase\r\n    .from('roles')\r\n    .update({ approval_group_id: null })\r\n    .eq('id', roleId)\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}"],"names":[],"mappings":";;;;;;;IA0RsB,qBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 589, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/components/RoleListModal.tsx"],"sourcesContent":["'use client'\r\nimport { useState, useEffect } from 'react'\r\nimport { getGroupRoles, getCompanyRoles, assignRoleToGroupAction, unassignRoleAction } from '../actions'\r\n\r\ninterface RoleListModalProps {\r\n  isOpen: boolean\r\n  onClose: () => void\r\n  onRoleUpdate: () => void\r\n  groupName: string\r\n  groupId: string\r\n  companyName: string\r\n  companyId: string\r\n  viewerRoleLevel: number // <--- NEW\r\n}\r\n\r\ntype Role = { id: string; role_name: string; default_role_level: number }\r\n\r\nexport default function RoleListModal({ \r\n  isOpen, onClose, onRoleUpdate, groupName, groupId, companyName, companyId, viewerRoleLevel\r\n}: RoleListModalProps) {\r\n  \r\n  const [currentRoles, setCurrentRoles] = useState<Role[]>([])\r\n  const [availableRoles, setAvailableRoles] = useState<Role[]>([])\r\n  const [loading, setLoading] = useState(true)\r\n  \r\n  // State for assignment selection\r\n  const [selectedRoleId, setSelectedRoleId] = useState('')\r\n  const [isAssigning, setIsAssigning] = useState(false)\r\n\r\n  // Permission Check: TAC or Admin (Level 60+)\r\n  const canModify = viewerRoleLevel >= 60;\r\n\r\n  useEffect(() => {\r\n    const handleKeyDown = (e: KeyboardEvent) => { if (e.key === 'Escape') onClose() }\r\n    if (isOpen) window.addEventListener('keydown', handleKeyDown)\r\n    return () => window.removeEventListener('keydown', handleKeyDown)\r\n  }, [isOpen, onClose])\r\n\r\n  // Fetch Data\r\n  const fetchData = async () => {\r\n      setLoading(true)\r\n      const [curr, avail] = await Promise.all([\r\n          getGroupRoles(groupId),\r\n          getCompanyRoles(companyId)\r\n      ])\r\n      setCurrentRoles(curr.roles)\r\n      setAvailableRoles(avail.roles)\r\n      setLoading(false)\r\n  }\r\n\r\n  useEffect(() => {\r\n    if (isOpen) fetchData()\r\n  }, [isOpen, groupId])\r\n\r\n  // Handlers\r\n  const handleAssign = async () => {\r\n      if (!selectedRoleId) return\r\n      setIsAssigning(true)\r\n      const res = await assignRoleToGroupAction(selectedRoleId, groupId)\r\n      setIsAssigning(false)\r\n      if (res.error) alert(res.error)\r\n      else {\r\n          setSelectedRoleId('')\r\n          fetchData()\r\n          onRoleUpdate()\r\n      }\r\n  }\r\n\r\n  const handleUnassign = async (roleId: string) => {\r\n      if(!confirm(\"Remove this role from the group? It will become unassigned.\")) return\r\n      const res = await unassignRoleAction(roleId)\r\n      if (res.error) alert(res.error)\r\n      else {\r\n          fetchData()\r\n          onRoleUpdate()\r\n      }\r\n  }\r\n\r\n  if (!isOpen) return null\r\n\r\n  return (\r\n    <div \r\n      className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm p-4\"\r\n      onClick={onClose} \r\n    >\r\n      <div \r\n        className=\"bg-white dark:bg-gray-800 rounded-xl shadow-2xl max-w-lg w-full border dark:border-gray-700 flex flex-col max-h-[85vh]\"\r\n        onClick={(e) => e.stopPropagation()}\r\n      >\r\n        <div className=\"p-6 border-b dark:border-gray-700 flex justify-between items-center\">\r\n          <div>\r\n            <h2 className=\"text-xl font-bold text-gray-900 dark:text-white\">{groupName}</h2>\r\n            <p className=\"text-sm text-gray-500\">Roles in this approval group</p>\r\n          </div>\r\n          <button onClick={onClose} className=\"text-gray-400 hover:text-gray-600 dark:hover:text-gray-200\"></button>\r\n        </div>\r\n\r\n        <div className=\"flex-1 overflow-y-auto p-6 space-y-3\">\r\n          {loading && <div className=\"text-center text-gray-500 py-4\">Loading...</div>}\r\n          \r\n          {!loading && currentRoles.length === 0 && (\r\n            <div className=\"text-center text-gray-500 py-8 italic\">No roles assigned yet.</div>\r\n          )}\r\n\r\n          {!loading && currentRoles.map(role => (\r\n            <div key={role.id} className=\"flex items-center justify-between p-3 bg-gray-50 dark:bg-gray-700/50 rounded-md border dark:border-gray-700\">\r\n              <div>\r\n                <div className=\"font-medium text-gray-800 dark:text-gray-200\">{role.role_name}</div>\r\n                <div className=\"text-xs text-gray-500\">Level: {role.default_role_level}</div>\r\n              </div>\r\n              {canModify && (\r\n                  <button \r\n                    onClick={() => handleUnassign(role.id)}\r\n                    className=\"text-red-500 hover:bg-red-50 dark:hover:bg-red-900/30 p-2 rounded text-sm\"\r\n                    title=\"Unassign Role\"\r\n                  >\r\n                    Remove\r\n                  </button>\r\n              )}\r\n            </div>\r\n          ))}\r\n        </div>\r\n\r\n        {/* FOOTER: Assign New Role (Restricted) */}\r\n        {canModify && (\r\n            <div className=\"p-6 border-t dark:border-gray-700 bg-gray-50 dark:bg-gray-900/50 rounded-b-xl\">\r\n              <h3 className=\"text-sm font-bold text-gray-700 dark:text-gray-300 uppercase tracking-wide mb-3\">Add Role to Group</h3>\r\n              <div className=\"flex gap-2\">\r\n                  <select \r\n                    className=\"flex-1 rounded-md border-gray-300 dark:border-gray-600 dark:bg-gray-800 dark:text-white text-sm p-2\"\r\n                    value={selectedRoleId}\r\n                    onChange={(e) => setSelectedRoleId(e.target.value)}\r\n                    disabled={availableRoles.length === 0}\r\n                  >\r\n                      <option value=\"\">{availableRoles.length === 0 ? \"No unassigned roles available\" : \"Select a role...\"}</option>\r\n                      {availableRoles.map(r => (\r\n                          <option key={r.id} value={r.id}>{r.role_name}</option>\r\n                      ))}\r\n                  </select>\r\n                  <button \r\n                    onClick={handleAssign}\r\n                    disabled={isAssigning || !selectedRoleId}\r\n                    className=\"px-4 py-2 bg-indigo-600 text-white rounded-md font-medium hover:bg-indigo-700 disabled:opacity-50 text-sm\"\r\n                  >\r\n                    {isAssigning ? 'Saving...' : 'Assign'}\r\n                  </button>\r\n              </div>\r\n              <p className=\"text-xs text-gray-500 mt-2\">Only unassigned roles for {companyName} are shown.</p>\r\n            </div>\r\n        )}\r\n        \r\n        {!canModify && (\r\n            <div className=\"p-4 border-t dark:border-gray-700 bg-yellow-50 dark:bg-yellow-900/20 rounded-b-xl text-center\">\r\n                <p className=\"text-xs text-yellow-800 dark:text-yellow-200\">\r\n                    Contact your TAC Officer or Admin to change role assignments.\r\n                </p>\r\n            </div>\r\n        )}\r\n\r\n      </div>\r\n    </div>\r\n  )\r\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 906, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/components/ChainVisualizer.tsx"],"sourcesContent":["'use client'\r\n\r\nimport React, { useState, useEffect, useMemo, useRef, useCallback } from 'react'\r\nimport { getCompanyChain, deleteGroupAction, type ApprovalGroupNode } from '../actions'\r\nimport GroupNode from './GroupNode'\r\nimport AddGroupModal from './AddGroupModal'\r\nimport RoleListModal from './RoleListModal'\r\n\r\ninterface ChainVisualizerProps {\r\n  initialCompanies: { id: string; company_name: string }[]\r\n  viewerRoleLevel: number // Defined here correctly\r\n}\r\n\r\nconst getInitialCompanyId = (companies: ChainVisualizerProps['initialCompanies']) => {\r\n    const alphaCompany = companies.find(c => c.company_name === 'Alpha Company');\r\n    return alphaCompany?.id || companies[0]?.id || '';\r\n}\r\n\r\n// *** FIX IS HERE: Added viewerRoleLevel to the destructuring ***\r\nexport default function ChainVisualizer({ initialCompanies, viewerRoleLevel }: ChainVisualizerProps) {\r\n    \r\n  const [selectedCompanyId, setSelectedCompanyId] = useState(() => getInitialCompanyId(initialCompanies));\r\n  \r\n  const [nodes, setNodes] = useState<ApprovalGroupNode[]>([])\r\n  const [loading, setLoading] = useState(false)\r\n  const contentRef = useRef<HTMLDivElement>(null)\r\n  const [connections, setConnections] = useState<{ path: string; key: string }[]>([])\r\n  \r\n  const [isAddModalOpen, setIsAddModalOpen] = useState(false)\r\n  const [targetGroupId, setTargetGroupId] = useState<string | null>(null)\r\n  \r\n  const [addMode, setAddMode] = useState<'genesis' | 'add_parent' | 'add_child'>('genesis') \r\n  \r\n  const [selectedNodeForRoles, setSelectedNodeForRoles] = useState<ApprovalGroupNode | null>(null)\r\n\r\n  useEffect(() => {\r\n    if (!selectedCompanyId) {\r\n        setNodes([]);\r\n        setLoading(false);\r\n        return;\r\n    }\r\n    fetchChain();\r\n  }, [selectedCompanyId])\r\n\r\n  async function fetchChain() {\r\n    setLoading(true)\r\n    const data = await getCompanyChain(selectedCompanyId)\r\n    setNodes(data || [])\r\n    setLoading(false)\r\n  }\r\n\r\n  const columns = useMemo(() => {\r\n    if (nodes.length === 0) return []\r\n\r\n    const depthMap = new Map<string, number>()\r\n    const adjacency = new Map<string, string[]>() \r\n\r\n    nodes.forEach(node => {\r\n      const parent = node.next_approver_group_id || 'ROOT'\r\n      if (!adjacency.has(parent)) adjacency.set(parent, [])\r\n      adjacency.get(parent)?.push(node.id)\r\n    })\r\n\r\n    function assignDepth(nodeId: string, currentDepth: number) {\r\n      const children = adjacency.get(nodeId) || []\r\n      children.forEach(childId => {\r\n        depthMap.set(childId, currentDepth + 1)\r\n        assignDepth(childId, currentDepth + 1)\r\n      })\r\n    }\r\n\r\n    const finalNodes = nodes.filter(n => n.is_final_authority || !n.next_approver_group_id)\r\n    finalNodes.forEach(node => {\r\n      depthMap.set(node.id, 0)\r\n      assignDepth(node.id, 0)\r\n    })\r\n\r\n    nodes.forEach(node => {\r\n      if (!depthMap.has(node.id)) depthMap.set(node.id, 0) \r\n    })\r\n\r\n    const maxDepth = Math.max(...Array.from(depthMap.values()), 0)\r\n    const cols: ApprovalGroupNode[][] = Array.from({ length: maxDepth + 1 }, () => [])\r\n\r\n    nodes.forEach(node => {\r\n      const depth = depthMap.get(node.id)\r\n      if (depth !== undefined) cols[depth].push(node)\r\n    })\r\n\r\n    cols.forEach(col => col.sort((a, b) => a.group_name.localeCompare(b.group_name)))\r\n    return cols.reverse() \r\n  }, [nodes])\r\n\r\n  const drawConnections = useCallback(() => {\r\n    if (!contentRef.current) return\r\n\r\n    if (nodes.length === 0) {\r\n        setConnections([])\r\n        return\r\n    }\r\n\r\n    const newConnections: { path: string; key: string }[] = []\r\n    const contentRect = contentRef.current.getBoundingClientRect()\r\n\r\n    nodes.forEach(node => {\r\n      if (!node.next_approver_group_id) return\r\n\r\n      const childEl = document.getElementById(`node-${node.id}`)\r\n      const parentEl = document.getElementById(`node-${node.next_approver_group_id}`)\r\n\r\n      if (childEl && parentEl) {\r\n        const childRect = childEl.getBoundingClientRect()\r\n        const parentRect = parentEl.getBoundingClientRect()\r\n\r\n        const startX = childRect.right - contentRect.left\r\n        const startY = (childRect.top + childRect.height / 2) - contentRect.top\r\n        \r\n        const endX = parentRect.left - contentRect.left\r\n        const endY = (parentRect.top + parentRect.height / 2) - contentRect.top\r\n\r\n        const path = `M ${startX} ${startY} L ${endX} ${endY}`\r\n        newConnections.push({ path, key: `${node.id}-${node.next_approver_group_id}` })\r\n      }\r\n    })\r\n\r\n    setConnections(newConnections)\r\n  }, [nodes])\r\n\r\n  useEffect(() => {\r\n    const timer = setTimeout(drawConnections, 50)\r\n    window.addEventListener('resize', drawConnections)\r\n    return () => {\r\n      window.removeEventListener('resize', drawConnections)\r\n      clearTimeout(timer)\r\n    }\r\n  }, [drawConnections, columns])\r\n\r\n  const handleDelete = async (id: string) => {\r\n    if (!confirm(\"Delete this group? Any groups pointing to it will be moved to its approver.\")) return\r\n    await deleteGroupAction(id)\r\n    fetchChain()\r\n  }\r\n\r\n  // --- Handlers for Modals ---\r\n  const openAddParent = (nodeId: string) => {\r\n      setTargetGroupId(nodeId);\r\n      setAddMode('add_parent');\r\n      setIsAddModalOpen(true);\r\n  }\r\n\r\n  const openAddChild = (nodeId: string) => {\r\n      setTargetGroupId(nodeId);\r\n      setAddMode('add_child');\r\n      setIsAddModalOpen(true);\r\n  }\r\n\r\n  const openGenesis = () => {\r\n      setTargetGroupId(null);\r\n      setAddMode('genesis');\r\n      setIsAddModalOpen(true);\r\n  }\r\n\r\n  const handleNodeClick = (node: ApprovalGroupNode) => {\r\n    setSelectedNodeForRoles(node)\r\n  }\r\n\r\n  return (\r\n    <div className=\"space-y-6\">\r\n      <div className=\"flex flex-wrap items-center gap-4 bg-white dark:bg-gray-800 p-4 rounded-lg shadow z-10 relative\">\r\n        <label className=\"font-medium text-gray-700 dark:text-gray-300\">Select Company:</label>\r\n        <select \r\n          value={selectedCompanyId} \r\n          onChange={(e) => setSelectedCompanyId(e.target.value)}\r\n          className=\"rounded-md border-gray-300 dark:border-gray-600 dark:bg-gray-900 dark:text-white p-2\"\r\n        >\r\n          {initialCompanies.map(c => <option key={c.id} value={c.id}>{c.company_name}</option>)}\r\n          {initialCompanies.length === 0 && <option value=\"\">No Companies Available</option>}\r\n        </select>\r\n        <button onClick={fetchChain} className=\"ml-auto text-sm text-indigo-600 hover:underline dark:text-indigo-400\">Refresh</button>\r\n      </div>\r\n\r\n      <div \r\n        className=\"overflow-x-auto bg-gray-50 dark:bg-gray-900/50 rounded-xl border dark:border-gray-700 flex flex-col\"\r\n        style={{ height: '700px' }}\r\n      >\r\n        {loading ? (\r\n          <div className=\"flex items-center justify-center h-full text-gray-500\">Loading Chain...</div>\r\n        ) : (\r\n          <div className=\"flex flex-col min-w-max h-full p-8 relative\">\r\n            \r\n            {/* HEADERS */}\r\n            {columns.length > 0 && (\r\n                <div className=\"flex gap-24 mb-4 border-b dark:border-gray-700 pb-2\">\r\n                {columns.map((_, colIndex) => (\r\n                    <div key={colIndex} className=\"w-64 text-center text-xs font-bold text-gray-400 uppercase tracking-wider\">\r\n                    {colIndex === columns.length - 1 ? \"Final Authority\" : `Step ${columns.length - 1 - colIndex}`}\r\n                    </div>\r\n                ))}\r\n                </div>\r\n            )}\r\n\r\n            {/* NODES */}\r\n            <div ref={contentRef} className=\"relative flex-grow flex items-center\">\r\n              <svg className=\"absolute top-0 left-0 w-full h-full pointer-events-none z-0\">\r\n                <defs>\r\n                  <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n                    <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#9CA3AF\" />\r\n                  </marker>\r\n                </defs>\r\n                {connections.map(conn => (\r\n                  <path \r\n                    key={conn.key} \r\n                    d={conn.path} \r\n                    stroke=\"#9CA3AF\" \r\n                    strokeWidth=\"2\" \r\n                    fill=\"none\" \r\n                    markerEnd=\"url(#arrowhead)\"\r\n                    className=\"opacity-60 transition-all duration-300\"\r\n                  />\r\n                ))}\r\n              </svg>\r\n\r\n              <div className=\"flex gap-24 z-10 relative h-full w-full\">\r\n                {columns.map((col, colIndex) => (\r\n                  <div key={colIndex} className=\"flex flex-col gap-16 justify-center w-64\">\r\n                    {col.map(node => (\r\n                      <div key={node.id} id={`node-${node.id}`} onClick={() => handleNodeClick(node)} className=\"cursor-pointer\">\r\n                        <GroupNode \r\n                          node={node} \r\n                          onDelete={(e: React.MouseEvent) => { e.stopPropagation(); handleDelete(node.id); }}\r\n                          onAddParent={(e: React.MouseEvent) => { e.stopPropagation(); openAddParent(node.id); }}\r\n                          onAddSubordinate={(e: React.MouseEvent) => { e.stopPropagation(); openAddChild(node.id); }}\r\n                        />\r\n                      </div>\r\n                    ))}\r\n                  </div>\r\n                ))}\r\n              </div>\r\n            </div>\r\n            \r\n            {/* EMPTY STATE */}\r\n            {!loading && columns.length === 0 && (\r\n                 <div className=\"absolute inset-0 flex flex-col items-center justify-center text-gray-500 gap-4 z-20\">\r\n                    <p>{initialCompanies.length === 0 \r\n                        ? \"Configuration error: No companies were loaded from the server.\"\r\n                        : \"No approval groups found for this company.\"}</p>\r\n                    \r\n                    {initialCompanies.length > 0 && selectedCompanyId && (\r\n                        <button \r\n                            onClick={openGenesis}\r\n                            className=\"px-4 py-2 bg-indigo-600 text-white rounded-md shadow-sm hover:bg-indigo-700 transition-colors\"\r\n                        >\r\n                            + Create First Group\r\n                        </button>\r\n                    )}\r\n                 </div>\r\n            )}\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {isAddModalOpen && (\r\n        <AddGroupModal \r\n          isOpen={isAddModalOpen}\r\n          onClose={() => setIsAddModalOpen(false)}\r\n          companyId={selectedCompanyId}\r\n          referenceGroupId={targetGroupId}\r\n          mode={addMode}\r\n          onSuccess={() => {\r\n            setIsAddModalOpen(false)\r\n            fetchChain()\r\n          }}\r\n        />\r\n      )}\r\n\r\n      {selectedNodeForRoles && (\r\n        <RoleListModal\r\n          isOpen={!!selectedNodeForRoles}\r\n          onClose={() => setSelectedNodeForRoles(null)}\r\n          onRoleUpdate={fetchChain}\r\n          groupName={selectedNodeForRoles.group_name}\r\n          groupId={selectedNodeForRoles.id}\r\n          companyName={initialCompanies.find(c => c.id === selectedCompanyId)?.company_name || 'Unit'}\r\n          companyId={selectedCompanyId}\r\n          viewerRoleLevel={viewerRoleLevel} // Now this variable exists!\r\n        />\r\n      )}\r\n    </div>\r\n  )\r\n}"],"names":[],"mappings":"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","debugId":null}}]
}