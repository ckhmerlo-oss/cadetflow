{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { createClient } from '@/utils/supabase/server'\r\nimport { revalidatePath } from 'next/cache'\r\nimport { SupabaseClient } from '@supabase/supabase-js'\r\n\r\nexport type ApprovalGroupNode = {\r\n  id: string;\r\n  group_name: string;\r\n  next_approver_group_id: string | null;\r\n  company_id: string;\r\n  is_final_authority: boolean;\r\n  role_count?: number; \r\n}\r\n\r\n// --- SECURITY HELPER ---\r\nasync function requireAuth(supabase: SupabaseClient) {\r\n  const { data: { user } } = await supabase.auth.getUser()\r\n  if (!user) throw new Error(\"Unauthorized\")\r\n\r\n  const { data: profile } = await supabase\r\n    .from('profiles')\r\n    .select('role:role_id(default_role_level)')\r\n    .eq('id', user.id)\r\n    .single()\r\n\r\n  const roleLevel = (profile?.role as any)?.default_role_level || 0\r\n  \r\n  if (roleLevel < 50) {\r\n    throw new Error(\"Insufficient permissions: You must be Staff to edit the Chain of Command.\")\r\n  }\r\n  \r\n  return user\r\n}\r\n\r\n// --- FETCHING ---\r\nexport async function getCompanyChain(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  const { data: companyGroups, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, group_name, next_approver_group_id, company_id, is_final_authority,\r\n      roles:roles(count)\r\n    `)\r\n    .eq('company_id', companyId)\r\n\r\n  if (error) {\r\n    console.error('Error fetching chain:', error)\r\n    return []\r\n  }\r\n\r\n  const formattedGroups = companyGroups.map(g => ({\r\n    ...g,\r\n    role_count: g.roles ? (g.roles as any)[0]?.count || 0 : 0\r\n  })) as ApprovalGroupNode[]\r\n\r\n  const outgoingLinkIds = formattedGroups\r\n    .map(g => g.next_approver_group_id)\r\n    .filter(id => id !== null) as string[];\r\n    \r\n  const existingIds = new Set(formattedGroups.map(g => g.id));\r\n  const missingIds = outgoingLinkIds.filter(id => !existingIds.has(id));\r\n\r\n  if (missingIds.length > 0) {\r\n    const { data: externalGroups } = await supabase\r\n      .from('approval_groups')\r\n      .select('id, group_name, next_approver_group_id, company_id, is_final_authority')\r\n      .in('id', missingIds);\r\n\r\n    if (externalGroups) {\r\n        formattedGroups.push(...(externalGroups as any[]));\r\n    }\r\n  }\r\n\r\n  return formattedGroups;\r\n}\r\n\r\nexport async function getGroupRoles(groupId: string) {\r\n  const supabase = createClient()\r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('approval_group_id', groupId)\r\n    .order('role_name')\r\n  \r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\n\r\n// --- MUTATIONS ---\r\n\r\nexport async function createGroupAction(\r\n  companyId: string, \r\n  groupName: string, \r\n  childGroupIdToApprove?: string | null // Made Optional\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  // CASE 1: INSERTING A PARENT (Standard)\r\n  if (childGroupIdToApprove) {\r\n      // 1. Get Child's current parent\r\n      const { data: childGroup, error: fetchError } = await supabase\r\n        .from('approval_groups')\r\n        .select('next_approver_group_id')\r\n        .eq('id', childGroupIdToApprove)\r\n        .single();\r\n\r\n      if (fetchError || !childGroup) return { error: \"Could not find the group you selected.\" };\r\n\r\n      const oldParentId = childGroup.next_approver_group_id;\r\n\r\n      // 2. Insert New Group\r\n      const { data: newGroup, error: createError } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: oldParentId,\r\n          is_final_authority: false // It might be final if oldParentId is null, but usually we flag manual finals\r\n        })\r\n        .select('id')\r\n        .single();\r\n\r\n      if (createError) return { error: createError.message };\r\n\r\n      // 3. Update Child\r\n      const { error: updateError } = await supabase\r\n        .from('approval_groups')\r\n        .update({ next_approver_group_id: newGroup.id })\r\n        .eq('id', childGroupIdToApprove);\r\n\r\n      if (updateError) return { error: \"Failed to re-link the chain.\" };\r\n  } \r\n  // CASE 2: CREATING FIRST GROUP (Genesis)\r\n  else {\r\n      const { error: createError } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: null,\r\n          is_final_authority: true\r\n        });\r\n\r\n      if (createError) return { error: createError.message };\r\n  }\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function deleteGroupAction(groupId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  // 1. Check for roles\r\n  const { count } = await supabase\r\n    .from('roles')\r\n    .select('*', { count: 'exact', head: true })\r\n    .eq('approval_group_id', groupId)\r\n  \r\n  if (count && count > 0) {\r\n    return { error: \"Cannot delete: This group still contains roles. Please move or delete them first.\" }\r\n  }\r\n\r\n  // 2. Get Target info\r\n  const { data: targetGroup } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', groupId)\r\n    .single();\r\n  \r\n  if (!targetGroup) return { error: \"Group not found\" };\r\n  const parentId = targetGroup.next_approver_group_id;\r\n\r\n  // 3. Re-link children\r\n  const { error: relinkError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ next_approver_group_id: parentId })\r\n    .eq('next_approver_group_id', groupId);\r\n\r\n  if (relinkError) return { error: \"Failed to re-link children groups.\" };\r\n\r\n  // 4. Delete\r\n  const { error: deleteError } = await supabase\r\n    .from('approval_groups')\r\n    .delete()\r\n    .eq('id', groupId);\r\n\r\n  if (deleteError) return { error: deleteError.message };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function createRoleAction(\r\n  companyId: string,\r\n  groupId: string,\r\n  roleName: string,\r\n  defaultLevel: number\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { error } = await supabase.from('roles').insert({\r\n    company_id: companyId,\r\n    approval_group_id: groupId,\r\n    role_name: roleName,\r\n    default_role_level: defaultLevel,\r\n    can_manage_own_company_roster: defaultLevel >= 40, \r\n    can_manage_all_rosters: defaultLevel >= 50\r\n  })\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}\r\n\r\nexport async function deleteRoleAction(roleId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n  \r\n  const { count } = await supabase\r\n    .from('profiles')\r\n    .select('*', { count: 'exact', head: true })\r\n    .eq('role_id', roleId)\r\n\r\n  if (count && count > 0) {\r\n    return { error: `Cannot delete: ${count} cadet(s) are currently assigned to this role.` }\r\n  }\r\n  \r\n  const { error } = await supabase.from('roles').delete().eq('id', roleId)\r\n  \r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}"],"names":[],"mappings":";;;;;;;IAoCsB,kBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { createClient } from '@/utils/supabase/server'\r\nimport { revalidatePath } from 'next/cache'\r\nimport { SupabaseClient } from '@supabase/supabase-js'\r\n\r\nexport type ApprovalGroupNode = {\r\n  id: string;\r\n  group_name: string;\r\n  next_approver_group_id: string | null;\r\n  company_id: string;\r\n  is_final_authority: boolean;\r\n  role_count?: number; \r\n}\r\n\r\n// --- SECURITY HELPER ---\r\nasync function requireAuth(supabase: SupabaseClient) {\r\n  const { data: { user } } = await supabase.auth.getUser()\r\n  if (!user) throw new Error(\"Unauthorized\")\r\n\r\n  const { data: profile } = await supabase\r\n    .from('profiles')\r\n    .select('role:role_id(default_role_level)')\r\n    .eq('id', user.id)\r\n    .single()\r\n\r\n  const roleLevel = (profile?.role as any)?.default_role_level || 0\r\n  \r\n  if (roleLevel < 50) {\r\n    throw new Error(\"Insufficient permissions: You must be Staff to edit the Chain of Command.\")\r\n  }\r\n  \r\n  return user\r\n}\r\n\r\n// --- FETCHING ---\r\nexport async function getCompanyChain(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  const { data: companyGroups, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, group_name, next_approver_group_id, company_id, is_final_authority,\r\n      roles:roles(count)\r\n    `)\r\n    .eq('company_id', companyId)\r\n\r\n  if (error) {\r\n    console.error('Error fetching chain:', error)\r\n    return []\r\n  }\r\n\r\n  const formattedGroups = companyGroups.map(g => ({\r\n    ...g,\r\n    role_count: g.roles ? (g.roles as any)[0]?.count || 0 : 0\r\n  })) as ApprovalGroupNode[]\r\n\r\n  const outgoingLinkIds = formattedGroups\r\n    .map(g => g.next_approver_group_id)\r\n    .filter(id => id !== null) as string[];\r\n    \r\n  const existingIds = new Set(formattedGroups.map(g => g.id));\r\n  const missingIds = outgoingLinkIds.filter(id => !existingIds.has(id));\r\n\r\n  if (missingIds.length > 0) {\r\n    const { data: externalGroups } = await supabase\r\n      .from('approval_groups')\r\n      .select('id, group_name, next_approver_group_id, company_id, is_final_authority')\r\n      .in('id', missingIds);\r\n\r\n    if (externalGroups) {\r\n        formattedGroups.push(...(externalGroups as any[]));\r\n    }\r\n  }\r\n\r\n  return formattedGroups;\r\n}\r\n\r\nexport async function getGroupRoles(groupId: string) {\r\n  const supabase = createClient()\r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('approval_group_id', groupId)\r\n    .order('role_name')\r\n  \r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\n\r\n// --- MUTATIONS ---\r\n\r\nexport async function createGroupAction(\r\n  companyId: string, \r\n  groupName: string, \r\n  childGroupIdToApprove?: string | null // Made Optional\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  // CASE 1: INSERTING A PARENT (Standard)\r\n  if (childGroupIdToApprove) {\r\n      // 1. Get Child's current parent\r\n      const { data: childGroup, error: fetchError } = await supabase\r\n        .from('approval_groups')\r\n        .select('next_approver_group_id')\r\n        .eq('id', childGroupIdToApprove)\r\n        .single();\r\n\r\n      if (fetchError || !childGroup) return { error: \"Could not find the group you selected.\" };\r\n\r\n      const oldParentId = childGroup.next_approver_group_id;\r\n\r\n      // 2. Insert New Group\r\n      const { data: newGroup, error: createError } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: oldParentId,\r\n          is_final_authority: false // It might be final if oldParentId is null, but usually we flag manual finals\r\n        })\r\n        .select('id')\r\n        .single();\r\n\r\n      if (createError) return { error: createError.message };\r\n\r\n      // 3. Update Child\r\n      const { error: updateError } = await supabase\r\n        .from('approval_groups')\r\n        .update({ next_approver_group_id: newGroup.id })\r\n        .eq('id', childGroupIdToApprove);\r\n\r\n      if (updateError) return { error: \"Failed to re-link the chain.\" };\r\n  } \r\n  // CASE 2: CREATING FIRST GROUP (Genesis)\r\n  else {\r\n      const { error: createError } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: null,\r\n          is_final_authority: true\r\n        });\r\n\r\n      if (createError) return { error: createError.message };\r\n  }\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function deleteGroupAction(groupId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  // 1. Check for roles\r\n  const { count } = await supabase\r\n    .from('roles')\r\n    .select('*', { count: 'exact', head: true })\r\n    .eq('approval_group_id', groupId)\r\n  \r\n  if (count && count > 0) {\r\n    return { error: \"Cannot delete: This group still contains roles. Please move or delete them first.\" }\r\n  }\r\n\r\n  // 2. Get Target info\r\n  const { data: targetGroup } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', groupId)\r\n    .single();\r\n  \r\n  if (!targetGroup) return { error: \"Group not found\" };\r\n  const parentId = targetGroup.next_approver_group_id;\r\n\r\n  // 3. Re-link children\r\n  const { error: relinkError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ next_approver_group_id: parentId })\r\n    .eq('next_approver_group_id', groupId);\r\n\r\n  if (relinkError) return { error: \"Failed to re-link children groups.\" };\r\n\r\n  // 4. Delete\r\n  const { error: deleteError } = await supabase\r\n    .from('approval_groups')\r\n    .delete()\r\n    .eq('id', groupId);\r\n\r\n  if (deleteError) return { error: deleteError.message };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function createRoleAction(\r\n  companyId: string,\r\n  groupId: string,\r\n  roleName: string,\r\n  defaultLevel: number\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { error } = await supabase.from('roles').insert({\r\n    company_id: companyId,\r\n    approval_group_id: groupId,\r\n    role_name: roleName,\r\n    default_role_level: defaultLevel,\r\n    can_manage_own_company_roster: defaultLevel >= 40, \r\n    can_manage_all_rosters: defaultLevel >= 50\r\n  })\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}\r\n\r\nexport async function deleteRoleAction(roleId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n  \r\n  const { count } = await supabase\r\n    .from('profiles')\r\n    .select('*', { count: 'exact', head: true })\r\n    .eq('role_id', roleId)\r\n\r\n  if (count && count > 0) {\r\n    return { error: `Cannot delete: ${count} cadet(s) are currently assigned to this role.` }\r\n  }\r\n  \r\n  const { error } = await supabase.from('roles').delete().eq('id', roleId)\r\n  \r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}"],"names":[],"mappings":";;;;;;;IAyJsB,oBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/components/GroupNode.tsx"],"sourcesContent":["// app/manage/roles/components/GroupNode.tsx\r\nimport { ApprovalGroupNode } from '../actions'\r\nimport React from 'react'\r\n\r\ninterface GroupNodeProps {\r\n  node: ApprovalGroupNode\r\n  onDelete: (e: React.MouseEvent) => void\r\n  onAddParent: (e: React.MouseEvent) => void\r\n}\r\n\r\nexport default function GroupNode({ node, onDelete, onAddParent }: GroupNodeProps) {\r\n  \r\n  const isFinal = node.is_final_authority\r\n  \r\n  return (\r\n    // Removed the \"relative group flex items-center\" wrapper that was holding the old line\r\n    // Now this is just the box itself, making the bounding calculation exact.\r\n    <div className={`\r\n      relative w-64 p-4 rounded-lg border-2 shadow-md transition-all hover:shadow-lg bg-white dark:bg-gray-800 group\r\n      ${isFinal ? 'border-yellow-500 dark:border-yellow-500 ring-2 ring-yellow-100 dark:ring-yellow-900/30' : 'border-gray-200 dark:border-gray-700'}\r\n    `}>\r\n      \r\n      {/* Header */}\r\n      <div className=\"flex justify-between items-start mb-2\">\r\n        <h3 className=\"font-bold text-gray-900 dark:text-white text-sm leading-tight\">\r\n          {node.group_name}\r\n        </h3>\r\n        {!isFinal && (\r\n           <button \r\n             onClick={onDelete}\r\n             className=\"text-gray-400 hover:text-red-600 transition-colors opacity-0 group-hover:opacity-100\"\r\n             title=\"Delete Group\"\r\n           >\r\n             <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" /></svg>\r\n           </button>\r\n        )}\r\n      </div>\r\n\r\n      {/* Stats */}\r\n      <div className=\"text-xs text-gray-500 dark:text-gray-400 flex gap-2\">\r\n        <span>Roles: {node.role_count || 0}</span>\r\n        {isFinal && <span className=\"text-yellow-600 font-semibold ml-auto\">Final Authority</span>}\r\n      </div>\r\n\r\n      {/* Insert Button - Positioned exactly on the right border */}\r\n      {!isFinal && (\r\n        <div className=\"absolute -right-4 top-1/2 -translate-y-1/2 z-20\">\r\n           <button \r\n             onClick={onAddParent}\r\n             className=\"flex items-center justify-center w-8 h-8 bg-indigo-600 text-white rounded-full shadow-sm hover:bg-indigo-700 hover:scale-110 transition-all border-2 border-white dark:border-gray-800\"\r\n             title=\"Insert Approval Level\"\r\n           >\r\n             <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 4v16m8-8H4\" /></svg>\r\n           </button>\r\n        </div>\r\n      )}\r\n    </div>\r\n  )\r\n}"],"names":[],"mappings":"AAAA,4CAA4C;;;;;;;AAU7B,SAAS,UAAU,EAAE,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAkB;IAE/E,MAAM,UAAU,KAAK,kBAAkB;IAEvC,OACE,uFAAuF;IACvF,0EAA0E;kBAC1E,6LAAC;QAAI,WAAW,CAAC;;MAEf,EAAE,UAAU,4FAA4F,uCAAuC;IACjJ,CAAC;;0BAGC,6LAAC;gBAAI,WAAU;;kCACb,6LAAC;wBAAG,WAAU;kCACX,KAAK,UAAU;;;;;;oBAEjB,CAAC,yBACC,6LAAC;wBACC,SAAS;wBACT,WAAU;wBACV,OAAM;kCAEN,cAAA,6LAAC;4BAAI,WAAU;4BAAU,MAAK;4BAAO,QAAO;4BAAe,SAAQ;sCAAY,cAAA,6LAAC;gCAAK,eAAc;gCAAQ,gBAAe;gCAAQ,aAAa;gCAAG,GAAE;;;;;;;;;;;;;;;;;;;;;;0BAM3J,6LAAC;gBAAI,WAAU;;kCACb,6LAAC;;4BAAK;4BAAQ,KAAK,UAAU,IAAI;;;;;;;oBAChC,yBAAW,6LAAC;wBAAK,WAAU;kCAAwC;;;;;;;;;;;;YAIrE,CAAC,yBACA,6LAAC;gBAAI,WAAU;0BACZ,cAAA,6LAAC;oBACC,SAAS;oBACT,WAAU;oBACV,OAAM;8BAEN,cAAA,6LAAC;wBAAI,WAAU;wBAAU,MAAK;wBAAO,QAAO;wBAAe,SAAQ;kCAAY,cAAA,6LAAC;4BAAK,eAAc;4BAAQ,gBAAe;4BAAQ,aAAa;4BAAG,GAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMjK;KAhDwB","debugId":null}},
    {"offset": {"line": 177, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { createClient } from '@/utils/supabase/server'\r\nimport { revalidatePath } from 'next/cache'\r\nimport { SupabaseClient } from '@supabase/supabase-js'\r\n\r\nexport type ApprovalGroupNode = {\r\n  id: string;\r\n  group_name: string;\r\n  next_approver_group_id: string | null;\r\n  company_id: string;\r\n  is_final_authority: boolean;\r\n  role_count?: number; \r\n}\r\n\r\n// --- SECURITY HELPER ---\r\nasync function requireAuth(supabase: SupabaseClient) {\r\n  const { data: { user } } = await supabase.auth.getUser()\r\n  if (!user) throw new Error(\"Unauthorized\")\r\n\r\n  const { data: profile } = await supabase\r\n    .from('profiles')\r\n    .select('role:role_id(default_role_level)')\r\n    .eq('id', user.id)\r\n    .single()\r\n\r\n  const roleLevel = (profile?.role as any)?.default_role_level || 0\r\n  \r\n  if (roleLevel < 50) {\r\n    throw new Error(\"Insufficient permissions: You must be Staff to edit the Chain of Command.\")\r\n  }\r\n  \r\n  return user\r\n}\r\n\r\n// --- FETCHING ---\r\nexport async function getCompanyChain(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  const { data: companyGroups, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, group_name, next_approver_group_id, company_id, is_final_authority,\r\n      roles:roles(count)\r\n    `)\r\n    .eq('company_id', companyId)\r\n\r\n  if (error) {\r\n    console.error('Error fetching chain:', error)\r\n    return []\r\n  }\r\n\r\n  const formattedGroups = companyGroups.map(g => ({\r\n    ...g,\r\n    role_count: g.roles ? (g.roles as any)[0]?.count || 0 : 0\r\n  })) as ApprovalGroupNode[]\r\n\r\n  const outgoingLinkIds = formattedGroups\r\n    .map(g => g.next_approver_group_id)\r\n    .filter(id => id !== null) as string[];\r\n    \r\n  const existingIds = new Set(formattedGroups.map(g => g.id));\r\n  const missingIds = outgoingLinkIds.filter(id => !existingIds.has(id));\r\n\r\n  if (missingIds.length > 0) {\r\n    const { data: externalGroups } = await supabase\r\n      .from('approval_groups')\r\n      .select('id, group_name, next_approver_group_id, company_id, is_final_authority')\r\n      .in('id', missingIds);\r\n\r\n    if (externalGroups) {\r\n        formattedGroups.push(...(externalGroups as any[]));\r\n    }\r\n  }\r\n\r\n  return formattedGroups;\r\n}\r\n\r\nexport async function getGroupRoles(groupId: string) {\r\n  const supabase = createClient()\r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('approval_group_id', groupId)\r\n    .order('role_name')\r\n  \r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\n\r\n// --- MUTATIONS ---\r\n\r\nexport async function createGroupAction(\r\n  companyId: string, \r\n  groupName: string, \r\n  childGroupIdToApprove?: string | null // Made Optional\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  // CASE 1: INSERTING A PARENT (Standard)\r\n  if (childGroupIdToApprove) {\r\n      // 1. Get Child's current parent\r\n      const { data: childGroup, error: fetchError } = await supabase\r\n        .from('approval_groups')\r\n        .select('next_approver_group_id')\r\n        .eq('id', childGroupIdToApprove)\r\n        .single();\r\n\r\n      if (fetchError || !childGroup) return { error: \"Could not find the group you selected.\" };\r\n\r\n      const oldParentId = childGroup.next_approver_group_id;\r\n\r\n      // 2. Insert New Group\r\n      const { data: newGroup, error: createError } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: oldParentId,\r\n          is_final_authority: false // It might be final if oldParentId is null, but usually we flag manual finals\r\n        })\r\n        .select('id')\r\n        .single();\r\n\r\n      if (createError) return { error: createError.message };\r\n\r\n      // 3. Update Child\r\n      const { error: updateError } = await supabase\r\n        .from('approval_groups')\r\n        .update({ next_approver_group_id: newGroup.id })\r\n        .eq('id', childGroupIdToApprove);\r\n\r\n      if (updateError) return { error: \"Failed to re-link the chain.\" };\r\n  } \r\n  // CASE 2: CREATING FIRST GROUP (Genesis)\r\n  else {\r\n      const { error: createError } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: null,\r\n          is_final_authority: true\r\n        });\r\n\r\n      if (createError) return { error: createError.message };\r\n  }\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function deleteGroupAction(groupId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  // 1. Check for roles\r\n  const { count } = await supabase\r\n    .from('roles')\r\n    .select('*', { count: 'exact', head: true })\r\n    .eq('approval_group_id', groupId)\r\n  \r\n  if (count && count > 0) {\r\n    return { error: \"Cannot delete: This group still contains roles. Please move or delete them first.\" }\r\n  }\r\n\r\n  // 2. Get Target info\r\n  const { data: targetGroup } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', groupId)\r\n    .single();\r\n  \r\n  if (!targetGroup) return { error: \"Group not found\" };\r\n  const parentId = targetGroup.next_approver_group_id;\r\n\r\n  // 3. Re-link children\r\n  const { error: relinkError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ next_approver_group_id: parentId })\r\n    .eq('next_approver_group_id', groupId);\r\n\r\n  if (relinkError) return { error: \"Failed to re-link children groups.\" };\r\n\r\n  // 4. Delete\r\n  const { error: deleteError } = await supabase\r\n    .from('approval_groups')\r\n    .delete()\r\n    .eq('id', groupId);\r\n\r\n  if (deleteError) return { error: deleteError.message };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function createRoleAction(\r\n  companyId: string,\r\n  groupId: string,\r\n  roleName: string,\r\n  defaultLevel: number\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { error } = await supabase.from('roles').insert({\r\n    company_id: companyId,\r\n    approval_group_id: groupId,\r\n    role_name: roleName,\r\n    default_role_level: defaultLevel,\r\n    can_manage_own_company_roster: defaultLevel >= 40, \r\n    can_manage_all_rosters: defaultLevel >= 50\r\n  })\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}\r\n\r\nexport async function deleteRoleAction(roleId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n  \r\n  const { count } = await supabase\r\n    .from('profiles')\r\n    .select('*', { count: 'exact', head: true })\r\n    .eq('role_id', roleId)\r\n\r\n  if (count && count > 0) {\r\n    return { error: `Cannot delete: ${count} cadet(s) are currently assigned to this role.` }\r\n  }\r\n  \r\n  const { error } = await supabase.from('roles').delete().eq('id', roleId)\r\n  \r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}"],"names":[],"mappings":";;;;;;;IA4FsB,oBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 192, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/components/AddGroupModal.tsx"],"sourcesContent":["'use client'\r\nimport { useState } from 'react'\r\nimport { createGroupAction } from '../actions'\r\n\r\ninterface AddGroupModalProps {\r\n  isOpen: boolean\r\n  onClose: () => void\r\n  companyId: string\r\n  childGroupId: string | null // Updated to allow null\r\n  onSuccess: () => void\r\n}\r\n\r\nexport default function AddGroupModal({ isOpen, onClose, companyId, childGroupId, onSuccess }: AddGroupModalProps) {\r\n  const [name, setName] = useState('')\r\n  const [loading, setLoading] = useState(false)\r\n\r\n  const isGenesis = !childGroupId; // Check if this is the first group\r\n\r\n  const handleSubmit = async (e: React.FormEvent) => {\r\n    e.preventDefault()\r\n    if (!name.trim()) return\r\n    \r\n    setLoading(true)\r\n    const result = await createGroupAction(companyId, name, childGroupId)\r\n    setLoading(false)\r\n\r\n    if (result?.error) {\r\n      alert(result.error)\r\n    } else {\r\n      onSuccess()\r\n    }\r\n  }\r\n\r\n  if (!isOpen) return null\r\n\r\n  return (\r\n    <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm\">\r\n      <div className=\"bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl w-96 border dark:border-gray-700\">\r\n        <h2 className=\"text-lg font-bold mb-4 text-gray-900 dark:text-white\">\r\n            {isGenesis ? 'Create First Group' : 'Insert Approval Step'}\r\n        </h2>\r\n        <p className=\"text-sm text-gray-500 mb-4\">\r\n          {isGenesis \r\n            ? \"This will be the first group in the chain. You can add parents or children to it later.\"\r\n            : \"This new group will approve reports coming from the selected group, and then forward them up the existing chain.\"\r\n          }\r\n        </p>\r\n        \r\n        <form onSubmit={handleSubmit}>\r\n          <div className=\"mb-4\">\r\n            <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">Group Name</label>\r\n            <input \r\n              type=\"text\" \r\n              value={name} \r\n              onChange={e => setName(e.target.value)}\r\n              placeholder={isGenesis ? \"e.g. Squad Leaders\" : \"e.g. Platoon Sergeant\"}\r\n              className=\"w-full rounded-md border-gray-300 dark:border-gray-600 dark:bg-gray-900 dark:text-white p-2\"\r\n              autoFocus\r\n            />\r\n          </div>\r\n\r\n          <div className=\"flex justify-end gap-2\">\r\n            <button type=\"button\" onClick={onClose} className=\"px-3 py-1.5 text-sm text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded\">Cancel</button>\r\n            <button \r\n              type=\"submit\" \r\n              disabled={loading || !name.trim()}\r\n              className=\"px-3 py-1.5 text-sm bg-indigo-600 text-white rounded hover:bg-indigo-700 disabled:opacity-50\"\r\n            >\r\n              {loading ? 'Saving...' : (isGenesis ? 'Create Group' : 'Create & Insert')}\r\n            </button>\r\n          </div>\r\n        </form>\r\n      </div>\r\n    </div>\r\n  )\r\n}"],"names":[],"mappings":";;;;;AACA;AACA;;;AAFA;;;AAYe,SAAS,cAAc,EAAE,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,YAAY,EAAE,SAAS,EAAsB;;IAC/G,MAAM,CAAC,MAAM,QAAQ,GAAG,IAAA,yKAAQ,EAAC;IACjC,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,yKAAQ,EAAC;IAEvC,MAAM,YAAY,CAAC,cAAc,mCAAmC;IAEpE,MAAM,eAAe,OAAO;QAC1B,EAAE,cAAc;QAChB,IAAI,CAAC,KAAK,IAAI,IAAI;QAElB,WAAW;QACX,MAAM,SAAS,MAAM,IAAA,sLAAiB,EAAC,WAAW,MAAM;QACxD,WAAW;QAEX,IAAI,QAAQ,OAAO;YACjB,MAAM,OAAO,KAAK;QACpB,OAAO;YACL;QACF;IACF;IAEA,IAAI,CAAC,QAAQ,OAAO;IAEpB,qBACE,6LAAC;QAAI,WAAU;kBACb,cAAA,6LAAC;YAAI,WAAU;;8BACb,6LAAC;oBAAG,WAAU;8BACT,YAAY,uBAAuB;;;;;;8BAExC,6LAAC;oBAAE,WAAU;8BACV,YACG,4FACA;;;;;;8BAIN,6LAAC;oBAAK,UAAU;;sCACd,6LAAC;4BAAI,WAAU;;8CACb,6LAAC;oCAAM,WAAU;8CAAkE;;;;;;8CACnF,6LAAC;oCACC,MAAK;oCACL,OAAO;oCACP,UAAU,CAAA,IAAK,QAAQ,EAAE,MAAM,CAAC,KAAK;oCACrC,aAAa,YAAY,uBAAuB;oCAChD,WAAU;oCACV,SAAS;;;;;;;;;;;;sCAIb,6LAAC;4BAAI,WAAU;;8CACb,6LAAC;oCAAO,MAAK;oCAAS,SAAS;oCAAS,WAAU;8CAAwG;;;;;;8CAC1J,6LAAC;oCACC,MAAK;oCACL,UAAU,WAAW,CAAC,KAAK,IAAI;oCAC/B,WAAU;8CAET,UAAU,cAAe,YAAY,iBAAiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOrE;GA/DwB;KAAA","debugId":null}},
    {"offset": {"line": 333, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { createClient } from '@/utils/supabase/server'\r\nimport { revalidatePath } from 'next/cache'\r\nimport { SupabaseClient } from '@supabase/supabase-js'\r\n\r\nexport type ApprovalGroupNode = {\r\n  id: string;\r\n  group_name: string;\r\n  next_approver_group_id: string | null;\r\n  company_id: string;\r\n  is_final_authority: boolean;\r\n  role_count?: number; \r\n}\r\n\r\n// --- SECURITY HELPER ---\r\nasync function requireAuth(supabase: SupabaseClient) {\r\n  const { data: { user } } = await supabase.auth.getUser()\r\n  if (!user) throw new Error(\"Unauthorized\")\r\n\r\n  const { data: profile } = await supabase\r\n    .from('profiles')\r\n    .select('role:role_id(default_role_level)')\r\n    .eq('id', user.id)\r\n    .single()\r\n\r\n  const roleLevel = (profile?.role as any)?.default_role_level || 0\r\n  \r\n  if (roleLevel < 50) {\r\n    throw new Error(\"Insufficient permissions: You must be Staff to edit the Chain of Command.\")\r\n  }\r\n  \r\n  return user\r\n}\r\n\r\n// --- FETCHING ---\r\nexport async function getCompanyChain(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  const { data: companyGroups, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, group_name, next_approver_group_id, company_id, is_final_authority,\r\n      roles:roles(count)\r\n    `)\r\n    .eq('company_id', companyId)\r\n\r\n  if (error) {\r\n    console.error('Error fetching chain:', error)\r\n    return []\r\n  }\r\n\r\n  const formattedGroups = companyGroups.map(g => ({\r\n    ...g,\r\n    role_count: g.roles ? (g.roles as any)[0]?.count || 0 : 0\r\n  })) as ApprovalGroupNode[]\r\n\r\n  const outgoingLinkIds = formattedGroups\r\n    .map(g => g.next_approver_group_id)\r\n    .filter(id => id !== null) as string[];\r\n    \r\n  const existingIds = new Set(formattedGroups.map(g => g.id));\r\n  const missingIds = outgoingLinkIds.filter(id => !existingIds.has(id));\r\n\r\n  if (missingIds.length > 0) {\r\n    const { data: externalGroups } = await supabase\r\n      .from('approval_groups')\r\n      .select('id, group_name, next_approver_group_id, company_id, is_final_authority')\r\n      .in('id', missingIds);\r\n\r\n    if (externalGroups) {\r\n        formattedGroups.push(...(externalGroups as any[]));\r\n    }\r\n  }\r\n\r\n  return formattedGroups;\r\n}\r\n\r\nexport async function getGroupRoles(groupId: string) {\r\n  const supabase = createClient()\r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('approval_group_id', groupId)\r\n    .order('role_name')\r\n  \r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\n\r\n// --- MUTATIONS ---\r\n\r\nexport async function createGroupAction(\r\n  companyId: string, \r\n  groupName: string, \r\n  childGroupIdToApprove?: string | null // Made Optional\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  // CASE 1: INSERTING A PARENT (Standard)\r\n  if (childGroupIdToApprove) {\r\n      // 1. Get Child's current parent\r\n      const { data: childGroup, error: fetchError } = await supabase\r\n        .from('approval_groups')\r\n        .select('next_approver_group_id')\r\n        .eq('id', childGroupIdToApprove)\r\n        .single();\r\n\r\n      if (fetchError || !childGroup) return { error: \"Could not find the group you selected.\" };\r\n\r\n      const oldParentId = childGroup.next_approver_group_id;\r\n\r\n      // 2. Insert New Group\r\n      const { data: newGroup, error: createError } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: oldParentId,\r\n          is_final_authority: false // It might be final if oldParentId is null, but usually we flag manual finals\r\n        })\r\n        .select('id')\r\n        .single();\r\n\r\n      if (createError) return { error: createError.message };\r\n\r\n      // 3. Update Child\r\n      const { error: updateError } = await supabase\r\n        .from('approval_groups')\r\n        .update({ next_approver_group_id: newGroup.id })\r\n        .eq('id', childGroupIdToApprove);\r\n\r\n      if (updateError) return { error: \"Failed to re-link the chain.\" };\r\n  } \r\n  // CASE 2: CREATING FIRST GROUP (Genesis)\r\n  else {\r\n      const { error: createError } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: null,\r\n          is_final_authority: true\r\n        });\r\n\r\n      if (createError) return { error: createError.message };\r\n  }\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function deleteGroupAction(groupId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  // 1. Check for roles\r\n  const { count } = await supabase\r\n    .from('roles')\r\n    .select('*', { count: 'exact', head: true })\r\n    .eq('approval_group_id', groupId)\r\n  \r\n  if (count && count > 0) {\r\n    return { error: \"Cannot delete: This group still contains roles. Please move or delete them first.\" }\r\n  }\r\n\r\n  // 2. Get Target info\r\n  const { data: targetGroup } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', groupId)\r\n    .single();\r\n  \r\n  if (!targetGroup) return { error: \"Group not found\" };\r\n  const parentId = targetGroup.next_approver_group_id;\r\n\r\n  // 3. Re-link children\r\n  const { error: relinkError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ next_approver_group_id: parentId })\r\n    .eq('next_approver_group_id', groupId);\r\n\r\n  if (relinkError) return { error: \"Failed to re-link children groups.\" };\r\n\r\n  // 4. Delete\r\n  const { error: deleteError } = await supabase\r\n    .from('approval_groups')\r\n    .delete()\r\n    .eq('id', groupId);\r\n\r\n  if (deleteError) return { error: deleteError.message };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function createRoleAction(\r\n  companyId: string,\r\n  groupId: string,\r\n  roleName: string,\r\n  defaultLevel: number\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { error } = await supabase.from('roles').insert({\r\n    company_id: companyId,\r\n    approval_group_id: groupId,\r\n    role_name: roleName,\r\n    default_role_level: defaultLevel,\r\n    can_manage_own_company_roster: defaultLevel >= 40, \r\n    can_manage_all_rosters: defaultLevel >= 50\r\n  })\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}\r\n\r\nexport async function deleteRoleAction(roleId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n  \r\n  const { count } = await supabase\r\n    .from('profiles')\r\n    .select('*', { count: 'exact', head: true })\r\n    .eq('role_id', roleId)\r\n\r\n  if (count && count > 0) {\r\n    return { error: `Cannot delete: ${count} cadet(s) are currently assigned to this role.` }\r\n  }\r\n  \r\n  const { error } = await supabase.from('roles').delete().eq('id', roleId)\r\n  \r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}"],"names":[],"mappings":";;;;;;;IA8EsB,gBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 348, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { createClient } from '@/utils/supabase/server'\r\nimport { revalidatePath } from 'next/cache'\r\nimport { SupabaseClient } from '@supabase/supabase-js'\r\n\r\nexport type ApprovalGroupNode = {\r\n  id: string;\r\n  group_name: string;\r\n  next_approver_group_id: string | null;\r\n  company_id: string;\r\n  is_final_authority: boolean;\r\n  role_count?: number; \r\n}\r\n\r\n// --- SECURITY HELPER ---\r\nasync function requireAuth(supabase: SupabaseClient) {\r\n  const { data: { user } } = await supabase.auth.getUser()\r\n  if (!user) throw new Error(\"Unauthorized\")\r\n\r\n  const { data: profile } = await supabase\r\n    .from('profiles')\r\n    .select('role:role_id(default_role_level)')\r\n    .eq('id', user.id)\r\n    .single()\r\n\r\n  const roleLevel = (profile?.role as any)?.default_role_level || 0\r\n  \r\n  if (roleLevel < 50) {\r\n    throw new Error(\"Insufficient permissions: You must be Staff to edit the Chain of Command.\")\r\n  }\r\n  \r\n  return user\r\n}\r\n\r\n// --- FETCHING ---\r\nexport async function getCompanyChain(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  const { data: companyGroups, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, group_name, next_approver_group_id, company_id, is_final_authority,\r\n      roles:roles(count)\r\n    `)\r\n    .eq('company_id', companyId)\r\n\r\n  if (error) {\r\n    console.error('Error fetching chain:', error)\r\n    return []\r\n  }\r\n\r\n  const formattedGroups = companyGroups.map(g => ({\r\n    ...g,\r\n    role_count: g.roles ? (g.roles as any)[0]?.count || 0 : 0\r\n  })) as ApprovalGroupNode[]\r\n\r\n  const outgoingLinkIds = formattedGroups\r\n    .map(g => g.next_approver_group_id)\r\n    .filter(id => id !== null) as string[];\r\n    \r\n  const existingIds = new Set(formattedGroups.map(g => g.id));\r\n  const missingIds = outgoingLinkIds.filter(id => !existingIds.has(id));\r\n\r\n  if (missingIds.length > 0) {\r\n    const { data: externalGroups } = await supabase\r\n      .from('approval_groups')\r\n      .select('id, group_name, next_approver_group_id, company_id, is_final_authority')\r\n      .in('id', missingIds);\r\n\r\n    if (externalGroups) {\r\n        formattedGroups.push(...(externalGroups as any[]));\r\n    }\r\n  }\r\n\r\n  return formattedGroups;\r\n}\r\n\r\nexport async function getGroupRoles(groupId: string) {\r\n  const supabase = createClient()\r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('approval_group_id', groupId)\r\n    .order('role_name')\r\n  \r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\n\r\n// --- MUTATIONS ---\r\n\r\nexport async function createGroupAction(\r\n  companyId: string, \r\n  groupName: string, \r\n  childGroupIdToApprove?: string | null // Made Optional\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  // CASE 1: INSERTING A PARENT (Standard)\r\n  if (childGroupIdToApprove) {\r\n      // 1. Get Child's current parent\r\n      const { data: childGroup, error: fetchError } = await supabase\r\n        .from('approval_groups')\r\n        .select('next_approver_group_id')\r\n        .eq('id', childGroupIdToApprove)\r\n        .single();\r\n\r\n      if (fetchError || !childGroup) return { error: \"Could not find the group you selected.\" };\r\n\r\n      const oldParentId = childGroup.next_approver_group_id;\r\n\r\n      // 2. Insert New Group\r\n      const { data: newGroup, error: createError } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: oldParentId,\r\n          is_final_authority: false // It might be final if oldParentId is null, but usually we flag manual finals\r\n        })\r\n        .select('id')\r\n        .single();\r\n\r\n      if (createError) return { error: createError.message };\r\n\r\n      // 3. Update Child\r\n      const { error: updateError } = await supabase\r\n        .from('approval_groups')\r\n        .update({ next_approver_group_id: newGroup.id })\r\n        .eq('id', childGroupIdToApprove);\r\n\r\n      if (updateError) return { error: \"Failed to re-link the chain.\" };\r\n  } \r\n  // CASE 2: CREATING FIRST GROUP (Genesis)\r\n  else {\r\n      const { error: createError } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: null,\r\n          is_final_authority: true\r\n        });\r\n\r\n      if (createError) return { error: createError.message };\r\n  }\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function deleteGroupAction(groupId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  // 1. Check for roles\r\n  const { count } = await supabase\r\n    .from('roles')\r\n    .select('*', { count: 'exact', head: true })\r\n    .eq('approval_group_id', groupId)\r\n  \r\n  if (count && count > 0) {\r\n    return { error: \"Cannot delete: This group still contains roles. Please move or delete them first.\" }\r\n  }\r\n\r\n  // 2. Get Target info\r\n  const { data: targetGroup } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', groupId)\r\n    .single();\r\n  \r\n  if (!targetGroup) return { error: \"Group not found\" };\r\n  const parentId = targetGroup.next_approver_group_id;\r\n\r\n  // 3. Re-link children\r\n  const { error: relinkError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ next_approver_group_id: parentId })\r\n    .eq('next_approver_group_id', groupId);\r\n\r\n  if (relinkError) return { error: \"Failed to re-link children groups.\" };\r\n\r\n  // 4. Delete\r\n  const { error: deleteError } = await supabase\r\n    .from('approval_groups')\r\n    .delete()\r\n    .eq('id', groupId);\r\n\r\n  if (deleteError) return { error: deleteError.message };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function createRoleAction(\r\n  companyId: string,\r\n  groupId: string,\r\n  roleName: string,\r\n  defaultLevel: number\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { error } = await supabase.from('roles').insert({\r\n    company_id: companyId,\r\n    approval_group_id: groupId,\r\n    role_name: roleName,\r\n    default_role_level: defaultLevel,\r\n    can_manage_own_company_roster: defaultLevel >= 40, \r\n    can_manage_all_rosters: defaultLevel >= 50\r\n  })\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}\r\n\r\nexport async function deleteRoleAction(roleId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n  \r\n  const { count } = await supabase\r\n    .from('profiles')\r\n    .select('*', { count: 'exact', head: true })\r\n    .eq('role_id', roleId)\r\n\r\n  if (count && count > 0) {\r\n    return { error: `Cannot delete: ${count} cadet(s) are currently assigned to this role.` }\r\n  }\r\n  \r\n  const { error } = await supabase.from('roles').delete().eq('id', roleId)\r\n  \r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}"],"names":[],"mappings":";;;;;;;IA4NsB,mBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 363, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { createClient } from '@/utils/supabase/server'\r\nimport { revalidatePath } from 'next/cache'\r\nimport { SupabaseClient } from '@supabase/supabase-js'\r\n\r\nexport type ApprovalGroupNode = {\r\n  id: string;\r\n  group_name: string;\r\n  next_approver_group_id: string | null;\r\n  company_id: string;\r\n  is_final_authority: boolean;\r\n  role_count?: number; \r\n}\r\n\r\n// --- SECURITY HELPER ---\r\nasync function requireAuth(supabase: SupabaseClient) {\r\n  const { data: { user } } = await supabase.auth.getUser()\r\n  if (!user) throw new Error(\"Unauthorized\")\r\n\r\n  const { data: profile } = await supabase\r\n    .from('profiles')\r\n    .select('role:role_id(default_role_level)')\r\n    .eq('id', user.id)\r\n    .single()\r\n\r\n  const roleLevel = (profile?.role as any)?.default_role_level || 0\r\n  \r\n  if (roleLevel < 50) {\r\n    throw new Error(\"Insufficient permissions: You must be Staff to edit the Chain of Command.\")\r\n  }\r\n  \r\n  return user\r\n}\r\n\r\n// --- FETCHING ---\r\nexport async function getCompanyChain(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  const { data: companyGroups, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, group_name, next_approver_group_id, company_id, is_final_authority,\r\n      roles:roles(count)\r\n    `)\r\n    .eq('company_id', companyId)\r\n\r\n  if (error) {\r\n    console.error('Error fetching chain:', error)\r\n    return []\r\n  }\r\n\r\n  const formattedGroups = companyGroups.map(g => ({\r\n    ...g,\r\n    role_count: g.roles ? (g.roles as any)[0]?.count || 0 : 0\r\n  })) as ApprovalGroupNode[]\r\n\r\n  const outgoingLinkIds = formattedGroups\r\n    .map(g => g.next_approver_group_id)\r\n    .filter(id => id !== null) as string[];\r\n    \r\n  const existingIds = new Set(formattedGroups.map(g => g.id));\r\n  const missingIds = outgoingLinkIds.filter(id => !existingIds.has(id));\r\n\r\n  if (missingIds.length > 0) {\r\n    const { data: externalGroups } = await supabase\r\n      .from('approval_groups')\r\n      .select('id, group_name, next_approver_group_id, company_id, is_final_authority')\r\n      .in('id', missingIds);\r\n\r\n    if (externalGroups) {\r\n        formattedGroups.push(...(externalGroups as any[]));\r\n    }\r\n  }\r\n\r\n  return formattedGroups;\r\n}\r\n\r\nexport async function getGroupRoles(groupId: string) {\r\n  const supabase = createClient()\r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('approval_group_id', groupId)\r\n    .order('role_name')\r\n  \r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\n\r\n// --- MUTATIONS ---\r\n\r\nexport async function createGroupAction(\r\n  companyId: string, \r\n  groupName: string, \r\n  childGroupIdToApprove?: string | null // Made Optional\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  // CASE 1: INSERTING A PARENT (Standard)\r\n  if (childGroupIdToApprove) {\r\n      // 1. Get Child's current parent\r\n      const { data: childGroup, error: fetchError } = await supabase\r\n        .from('approval_groups')\r\n        .select('next_approver_group_id')\r\n        .eq('id', childGroupIdToApprove)\r\n        .single();\r\n\r\n      if (fetchError || !childGroup) return { error: \"Could not find the group you selected.\" };\r\n\r\n      const oldParentId = childGroup.next_approver_group_id;\r\n\r\n      // 2. Insert New Group\r\n      const { data: newGroup, error: createError } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: oldParentId,\r\n          is_final_authority: false // It might be final if oldParentId is null, but usually we flag manual finals\r\n        })\r\n        .select('id')\r\n        .single();\r\n\r\n      if (createError) return { error: createError.message };\r\n\r\n      // 3. Update Child\r\n      const { error: updateError } = await supabase\r\n        .from('approval_groups')\r\n        .update({ next_approver_group_id: newGroup.id })\r\n        .eq('id', childGroupIdToApprove);\r\n\r\n      if (updateError) return { error: \"Failed to re-link the chain.\" };\r\n  } \r\n  // CASE 2: CREATING FIRST GROUP (Genesis)\r\n  else {\r\n      const { error: createError } = await supabase\r\n        .from('approval_groups')\r\n        .insert({\r\n          group_name: groupName,\r\n          company_id: companyId,\r\n          next_approver_group_id: null,\r\n          is_final_authority: true\r\n        });\r\n\r\n      if (createError) return { error: createError.message };\r\n  }\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function deleteGroupAction(groupId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  // 1. Check for roles\r\n  const { count } = await supabase\r\n    .from('roles')\r\n    .select('*', { count: 'exact', head: true })\r\n    .eq('approval_group_id', groupId)\r\n  \r\n  if (count && count > 0) {\r\n    return { error: \"Cannot delete: This group still contains roles. Please move or delete them first.\" }\r\n  }\r\n\r\n  // 2. Get Target info\r\n  const { data: targetGroup } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', groupId)\r\n    .single();\r\n  \r\n  if (!targetGroup) return { error: \"Group not found\" };\r\n  const parentId = targetGroup.next_approver_group_id;\r\n\r\n  // 3. Re-link children\r\n  const { error: relinkError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ next_approver_group_id: parentId })\r\n    .eq('next_approver_group_id', groupId);\r\n\r\n  if (relinkError) return { error: \"Failed to re-link children groups.\" };\r\n\r\n  // 4. Delete\r\n  const { error: deleteError } = await supabase\r\n    .from('approval_groups')\r\n    .delete()\r\n    .eq('id', groupId);\r\n\r\n  if (deleteError) return { error: deleteError.message };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\nexport async function createRoleAction(\r\n  companyId: string,\r\n  groupId: string,\r\n  roleName: string,\r\n  defaultLevel: number\r\n) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n\r\n  const { error } = await supabase.from('roles').insert({\r\n    company_id: companyId,\r\n    approval_group_id: groupId,\r\n    role_name: roleName,\r\n    default_role_level: defaultLevel,\r\n    can_manage_own_company_roster: defaultLevel >= 40, \r\n    can_manage_all_rosters: defaultLevel >= 50\r\n  })\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}\r\n\r\nexport async function deleteRoleAction(roleId: string) {\r\n  const supabase = createClient()\r\n  try { await requireAuth(supabase) } catch (e: any) { return { error: e.message } }\r\n  \r\n  const { count } = await supabase\r\n    .from('profiles')\r\n    .select('*', { count: 'exact', head: true })\r\n    .eq('role_id', roleId)\r\n\r\n  if (count && count > 0) {\r\n    return { error: `Cannot delete: ${count} cadet(s) are currently assigned to this role.` }\r\n  }\r\n  \r\n  const { error } = await supabase.from('roles').delete().eq('id', roleId)\r\n  \r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}"],"names":[],"mappings":";;;;;;;IAqMsB,mBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 384, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/components/ChainVisualizer.tsx"],"sourcesContent":["'use client'\r\n\r\nimport React, { useState, useEffect, useMemo, useRef, useCallback } from 'react'\r\nimport { getCompanyChain, deleteGroupAction, type ApprovalGroupNode } from '../actions'\r\nimport GroupNode from './GroupNode'\r\nimport AddGroupModal from './AddGroupModal'\r\nimport RoleListModal from './RoleListModal'\r\n\r\ninterface ChainVisualizerProps {\r\n  initialCompanies: { id: string; company_name: string }[]\r\n}\r\n\r\nconst getInitialCompanyId = (companies: ChainVisualizerProps['initialCompanies']) => {\r\n    const alphaCompany = companies.find(c => c.company_name === 'Alpha Company');\r\n    return alphaCompany?.id || companies[0]?.id || '';\r\n}\r\n\r\nexport default function ChainVisualizer({ initialCompanies }: ChainVisualizerProps) {\r\n    \r\n  const [selectedCompanyId, setSelectedCompanyId] = useState(() => getInitialCompanyId(initialCompanies));\r\n  \r\n  const [nodes, setNodes] = useState<ApprovalGroupNode[]>([])\r\n  const [loading, setLoading] = useState(false)\r\n  const contentRef = useRef<HTMLDivElement>(null)\r\n  const [connections, setConnections] = useState<{ path: string; key: string }[]>([])\r\n  \r\n  const [isAddModalOpen, setIsAddModalOpen] = useState(false)\r\n  const [targetChildId, setTargetChildId] = useState<string | null>(null)\r\n  const [selectedNodeForRoles, setSelectedNodeForRoles] = useState<ApprovalGroupNode | null>(null)\r\n\r\n  useEffect(() => {\r\n    if (!selectedCompanyId) {\r\n        setNodes([]);\r\n        setLoading(false);\r\n        return;\r\n    }\r\n    fetchChain();\r\n  }, [selectedCompanyId])\r\n\r\n  async function fetchChain() {\r\n    setLoading(true)\r\n    const data = await getCompanyChain(selectedCompanyId)\r\n    setNodes(data || [])\r\n    setLoading(false)\r\n  }\r\n\r\n  const columns = useMemo(() => {\r\n    if (nodes.length === 0) return []\r\n\r\n    const depthMap = new Map<string, number>()\r\n    const adjacency = new Map<string, string[]>() \r\n\r\n    nodes.forEach(node => {\r\n      const parent = node.next_approver_group_id || 'ROOT'\r\n      if (!adjacency.has(parent)) adjacency.set(parent, [])\r\n      adjacency.get(parent)?.push(node.id)\r\n    })\r\n\r\n    function assignDepth(nodeId: string, currentDepth: number) {\r\n      const children = adjacency.get(nodeId) || []\r\n      children.forEach(childId => {\r\n        depthMap.set(childId, currentDepth + 1)\r\n        assignDepth(childId, currentDepth + 1)\r\n      })\r\n    }\r\n\r\n    const finalNodes = nodes.filter(n => n.is_final_authority || !n.next_approver_group_id)\r\n    finalNodes.forEach(node => {\r\n      depthMap.set(node.id, 0)\r\n      assignDepth(node.id, 0)\r\n    })\r\n\r\n    nodes.forEach(node => {\r\n      if (!depthMap.has(node.id)) depthMap.set(node.id, 0) \r\n    })\r\n\r\n    const maxDepth = Math.max(...Array.from(depthMap.values()), 0)\r\n    const cols: ApprovalGroupNode[][] = Array.from({ length: maxDepth + 1 }, () => [])\r\n\r\n    nodes.forEach(node => {\r\n      const depth = depthMap.get(node.id)\r\n      if (depth !== undefined) cols[depth].push(node)\r\n    })\r\n\r\n    cols.forEach(col => col.sort((a, b) => a.group_name.localeCompare(b.group_name)))\r\n    return cols.reverse() \r\n  }, [nodes])\r\n\r\n  // --- UPDATED: Fix Ghost Arrows ---\r\n  const drawConnections = useCallback(() => {\r\n    if (!contentRef.current) return\r\n\r\n    // FIX: Explicitly clear connections if nodes are empty\r\n    if (nodes.length === 0) {\r\n        setConnections([])\r\n        return\r\n    }\r\n\r\n    const newConnections: { path: string; key: string }[] = []\r\n    const contentRect = contentRef.current.getBoundingClientRect()\r\n\r\n    nodes.forEach(node => {\r\n      if (!node.next_approver_group_id) return\r\n\r\n      const childEl = document.getElementById(`node-${node.id}`)\r\n      const parentEl = document.getElementById(`node-${node.next_approver_group_id}`)\r\n\r\n      if (childEl && parentEl) {\r\n        const childRect = childEl.getBoundingClientRect()\r\n        const parentRect = parentEl.getBoundingClientRect()\r\n\r\n        const startX = childRect.right - contentRect.left\r\n        const startY = (childRect.top + childRect.height / 2) - contentRect.top\r\n        \r\n        const endX = parentRect.left - contentRect.left\r\n        const endY = (parentRect.top + parentRect.height / 2) - contentRect.top\r\n\r\n        const path = `M ${startX} ${startY} L ${endX} ${endY}`\r\n        newConnections.push({ path, key: `${node.id}-${node.next_approver_group_id}` })\r\n      }\r\n    })\r\n\r\n    setConnections(newConnections)\r\n  }, [nodes])\r\n\r\n  useEffect(() => {\r\n    const timer = setTimeout(drawConnections, 50)\r\n    window.addEventListener('resize', drawConnections)\r\n    return () => {\r\n      window.removeEventListener('resize', drawConnections)\r\n      clearTimeout(timer)\r\n    }\r\n  }, [drawConnections, columns])\r\n\r\n  const handleDelete = async (id: string) => {\r\n    if (!confirm(\"Delete this group? Any groups pointing to it will be moved to its approver.\")) return\r\n    await deleteGroupAction(id)\r\n    fetchChain()\r\n  }\r\n  const handleOpenAdd = (childId: string) => {\r\n    setTargetChildId(childId)\r\n    setIsAddModalOpen(true)\r\n  }\r\n  const handleNodeClick = (node: ApprovalGroupNode) => {\r\n    setSelectedNodeForRoles(node)\r\n  }\r\n\r\n  const handleCreateFirst = () => {\r\n      setTargetChildId(null); \r\n      setIsAddModalOpen(true);\r\n  }\r\n\r\n  return (\r\n    <div className=\"space-y-6\">\r\n      {/* Toolbar */}\r\n      <div className=\"flex flex-wrap items-center gap-4 bg-white dark:bg-gray-800 p-4 rounded-lg shadow z-10 relative\">\r\n        <label className=\"font-medium text-gray-700 dark:text-gray-300\">Select Company:</label>\r\n        <select \r\n          value={selectedCompanyId} \r\n          onChange={(e) => setSelectedCompanyId(e.target.value)}\r\n          className=\"rounded-md border-gray-300 dark:border-gray-600 dark:bg-gray-900 dark:text-white p-2\"\r\n        >\r\n          {initialCompanies.map(c => <option key={c.id} value={c.id}>{c.company_name}</option>)}\r\n          {initialCompanies.length === 0 && <option value=\"\">No Companies Available</option>}\r\n        </select>\r\n        <button onClick={fetchChain} className=\"ml-auto text-sm text-indigo-600 hover:underline dark:text-indigo-400\">Refresh</button>\r\n      </div>\r\n\r\n      <div \r\n        className=\"overflow-x-auto bg-gray-50 dark:bg-gray-900/50 rounded-xl border dark:border-gray-700 flex flex-col\"\r\n        style={{ height: '700px' }}\r\n      >\r\n        {loading ? (\r\n          <div className=\"flex items-center justify-center h-full text-gray-500\">Loading Chain...</div>\r\n        ) : (\r\n          <div className=\"flex flex-col min-w-max h-full p-8 relative\">\r\n            \r\n            {/* HEADERS */}\r\n            {columns.length > 0 && (\r\n                <div className=\"flex gap-24 mb-4 border-b dark:border-gray-700 pb-2\">\r\n                {columns.map((_, colIndex) => (\r\n                    <div key={colIndex} className=\"w-64 text-center text-xs font-bold text-gray-400 uppercase tracking-wider\">\r\n                    {colIndex === columns.length - 1 ? \"Final Authority\" : `Step ${columns.length - 1 - colIndex}`}\r\n                    </div>\r\n                ))}\r\n                </div>\r\n            )}\r\n\r\n            {/* NODES & LINES */}\r\n            <div ref={contentRef} className=\"relative flex-grow flex items-center\">\r\n              <svg className=\"absolute top-0 left-0 w-full h-full pointer-events-none z-0\">\r\n                <defs>\r\n                  <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"9\" refY=\"3.5\" orient=\"auto\">\r\n                    <polygon points=\"0 0, 10 3.5, 0 7\" fill=\"#9CA3AF\" />\r\n                  </marker>\r\n                </defs>\r\n                {connections.map(conn => (\r\n                  <path \r\n                    key={conn.key} \r\n                    d={conn.path} \r\n                    stroke=\"#9CA3AF\" \r\n                    strokeWidth=\"2\" \r\n                    fill=\"none\" \r\n                    markerEnd=\"url(#arrowhead)\"\r\n                    className=\"opacity-60 transition-all duration-300\"\r\n                  />\r\n                ))}\r\n              </svg>\r\n\r\n              <div className=\"flex gap-24 z-10 relative h-full w-full\">\r\n                {columns.map((col, colIndex) => (\r\n                  <div key={colIndex} className=\"flex flex-col gap-16 justify-center w-64\">\r\n                    {col.map(node => (\r\n                      <div key={node.id} id={`node-${node.id}`} onClick={() => handleNodeClick(node)} className=\"cursor-pointer\">\r\n                        <GroupNode \r\n                          node={node} \r\n                          onDelete={(e: React.MouseEvent) => { e.stopPropagation(); handleDelete(node.id); }}\r\n                          onAddParent={(e: React.MouseEvent) => { e.stopPropagation(); handleOpenAdd(node.id); }}\r\n                        />\r\n                      </div>\r\n                    ))}\r\n                  </div>\r\n                ))}\r\n              </div>\r\n            </div>\r\n            \r\n            {/* EMPTY STATE */}\r\n            {!loading && columns.length === 0 && (\r\n                 // UPDATED: Added z-20 to ensure it sits on top of the empty node container layer\r\n                 <div className=\"absolute inset-0 flex flex-col items-center justify-center text-gray-500 gap-4 z-20\">\r\n                    <p>{initialCompanies.length === 0 \r\n                        ? \"Configuration error: No companies were loaded from the server.\"\r\n                        : \"No approval groups found for this company.\"}</p>\r\n                    \r\n                    {initialCompanies.length > 0 && selectedCompanyId && (\r\n                        <button \r\n                            onClick={handleCreateFirst}\r\n                            className=\"px-4 py-2 bg-indigo-600 text-white rounded-md shadow-sm hover:bg-indigo-700 transition-colors\"\r\n                        >\r\n                            + Create First Group\r\n                        </button>\r\n                    )}\r\n                 </div>\r\n            )}\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {isAddModalOpen && (\r\n        <AddGroupModal \r\n          isOpen={isAddModalOpen}\r\n          onClose={() => setIsAddModalOpen(false)}\r\n          companyId={selectedCompanyId}\r\n          childGroupId={targetChildId}\r\n          onSuccess={() => {\r\n            setIsAddModalOpen(false)\r\n            fetchChain()\r\n          }}\r\n        />\r\n      )}\r\n\r\n      {selectedNodeForRoles && (\r\n        <RoleListModal\r\n          isOpen={!!selectedNodeForRoles}\r\n          onClose={() => setSelectedNodeForRoles(null)}\r\n          onRoleUpdate={fetchChain}\r\n          groupName={selectedNodeForRoles.group_name}\r\n          groupId={selectedNodeForRoles.id}\r\n          companyName={initialCompanies.find(c => c.id === selectedCompanyId)?.company_name || 'Unit'}\r\n          companyId={selectedCompanyId}\r\n        />\r\n      )}\r\n    </div>\r\n  )\r\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 824, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/node_modules/next/src/build/webpack/loaders/next-flight-loader/action-client-wrapper.ts"],"sourcesContent":["// This file must be bundled in the app's client layer, it shouldn't be directly\n// imported by the server.\n\nexport { callServer } from 'next/dist/client/app-call-server'\nexport { findSourceMapURL } from 'next/dist/client/app-find-source-map-url'\n\n// A noop wrapper to let the Flight client create the server reference.\n// See also: https://github.com/facebook/react/pull/26632\n// eslint-disable-next-line import/no-extraneous-dependencies\nexport { createServerReference } from 'react-server-dom-webpack/client'\n"],"names":["callServer","createServerReference","findSourceMapURL"],"mappings":"AAAA,gFAAgF;AAChF,0BAA0B;;;;;;;;;;;;;;;;IAEjBA,UAAU,EAAA;eAAVA,eAAAA,UAAU;;IAMVC,qBAAqB,EAAA;eAArBA,QAAAA,qBAAqB;;IALrBC,gBAAgB,EAAA;eAAhBA,qBAAAA,gBAAgB;;;+BADE;qCACM;wBAKK","ignoreList":[0],"debugId":null}}]
}