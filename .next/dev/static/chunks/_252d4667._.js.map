{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { createClient } from '@/utils/supabase/server'\r\nimport { revalidatePath } from 'next/cache'\r\n\r\nexport type ApprovalGroupNode = {\r\n  id: string;\r\n  group_name: string;\r\n  next_approver_group_id: string | null;\r\n  company_id: string;\r\n  is_final_authority: boolean;\r\n  role_count?: number; // We'll fetch how many roles are in this group\r\n}\r\n\r\n/**\r\n * Fetches the flat list of groups for a company.\r\n * The visualizer will reconstruct the tree from this flat list.\r\n */\r\nexport async function getCompanyChain(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // 1. Fetch groups for the company\r\n  const { data: companyGroups, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, \r\n      group_name, \r\n      next_approver_group_id, \r\n      company_id, \r\n      is_final_authority,\r\n      roles:roles(count)\r\n    `)\r\n    .eq('company_id', companyId)\r\n\r\n  if (error) {\r\n    console.error('Error fetching chain:', error)\r\n    return []\r\n  }\r\n\r\n  // 2. Flatten the count\r\n  // (Supabase returns { count: 5 } array, we just want the number)\r\n  const formattedGroups = companyGroups.map(g => ({\r\n    ...g,\r\n    role_count: g.roles ? (g.roles as any)[0]?.count || 0 : 0\r\n  })) as ApprovalGroupNode[]\r\n\r\n  // 3. Fetch the \"Final Authority\" groups (Commandant/Battalion) \r\n  // We need these to show the end of the chain, even if they belong to a different company\r\n  // We find them by looking at the 'next_approver_group_id' of the top-level company groups\r\n  const outgoingLinkIds = formattedGroups\r\n    .map(g => g.next_approver_group_id)\r\n    .filter(id => id !== null) as string[];\r\n    \r\n  // If an outgoing link points to a group NOT in our fetched list, fetch it now\r\n  const existingIds = new Set(formattedGroups.map(g => g.id));\r\n  const missingIds = outgoingLinkIds.filter(id => !existingIds.has(id));\r\n\r\n  if (missingIds.length > 0) {\r\n    const { data: externalGroups } = await supabase\r\n      .from('approval_groups')\r\n      .select('id, group_name, next_approver_group_id, company_id, is_final_authority')\r\n      .in('id', missingIds);\r\n\r\n    if (externalGroups) {\r\n        // Add external nodes (like Commandant Staff) to the list so we can render them\r\n        formattedGroups.push(...(externalGroups as any[]));\r\n    }\r\n  }\r\n\r\n  return formattedGroups;\r\n}\r\n\r\n/**\r\n * INSERT LOGIC:\r\n * User selects \"Who does this new group approve?\" (Child Group).\r\n * We insert the New Group *between* the Child and the Child's current approver.\r\n */\r\nexport async function createGroupAction(\r\n  companyId: string, \r\n  groupName: string, \r\n  childGroupIdToApprove: string // The group that will report TO this new group\r\n) {\r\n  const supabase = createClient()\r\n\r\n  // 1. Get the Child Group to see who it currently points to\r\n  const { data: childGroup, error: fetchError } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', childGroupIdToApprove)\r\n    .single();\r\n\r\n  if (fetchError || !childGroup) return { error: \"Could not find the group you selected to approve.\" };\r\n\r\n  const oldParentId = childGroup.next_approver_group_id;\r\n\r\n  // 2. Create the New Group\r\n  // Point it to the Child's OLD parent (or null if Child was top)\r\n  const { data: newGroup, error: createError } = await supabase\r\n    .from('approval_groups')\r\n    .insert({\r\n      group_name: groupName,\r\n      company_id: companyId,\r\n      next_approver_group_id: oldParentId,\r\n      is_final_authority: false\r\n    })\r\n    .select('id')\r\n    .single();\r\n\r\n  if (createError) return { error: createError.message };\r\n\r\n  // 3. Update the Child Group\r\n  // Point it to the NEW group\r\n  const { error: updateError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ next_approver_group_id: newGroup.id })\r\n    .eq('id', childGroupIdToApprove);\r\n\r\n  if (updateError) return { error: \"Failed to re-link the chain.\" };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n/**\r\n * DELETE LOGIC:\r\n * 1. Find who the target group points to (Parent).\r\n * 2. Find everyone pointing TO the target group (Children).\r\n * 3. Point all Children to the Parent.\r\n * 4. Delete the target.\r\n */\r\nexport async function deleteGroupAction(groupId: string) {\r\n  const supabase = createClient()\r\n\r\n  // 1. Get Target info\r\n  const { data: targetGroup } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', groupId)\r\n    .single();\r\n  \r\n  if (!targetGroup) return { error: \"Group not found\" };\r\n\r\n  const parentId = targetGroup.next_approver_group_id;\r\n\r\n  // 2. Re-link children (Update Step)\r\n  const { error: relinkError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ next_approver_group_id: parentId })\r\n    .eq('next_approver_group_id', groupId); // Find anyone pointing to ME\r\n\r\n  if (relinkError) return { error: \"Failed to re-link children groups.\" };\r\n\r\n  // 3. Delete the group\r\n  const { error: deleteError } = await supabase\r\n    .from('approval_groups')\r\n    .delete()\r\n    .eq('id', groupId);\r\n\r\n  if (deleteError) return { error: deleteError.message };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n// ... existing imports and code\r\n\r\n// --- ROLE MANAGEMENT ---\r\n\r\nexport async function getGroupRoles(groupId: string) {\r\n  const supabase = createClient()\r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('approval_group_id', groupId)\r\n    .order('role_name')\r\n  \r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\nexport async function deleteRoleAction(roleId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // Security check: ensure no users are assigned? \r\n  // For now, we'll just delete. Supabase might throw FK error if used.\r\n  const { error } = await supabase.from('roles').delete().eq('id', roleId)\r\n  \r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}\r\n\r\nexport async function createRoleAction(\r\n  companyId: string,\r\n  groupId: string,\r\n  roleName: string,\r\n  defaultLevel: number\r\n) {\r\n  const supabase = createClient()\r\n\r\n  const { error } = await supabase.from('roles').insert({\r\n    company_id: companyId,\r\n    approval_group_id: groupId,\r\n    role_name: roleName,\r\n    default_role_level: defaultLevel,\r\n    can_manage_own_company_roster: defaultLevel >= 40, // Basic logic\r\n    can_manage_all_rosters: defaultLevel >= 50\r\n  })\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}"],"names":[],"mappings":";;;;;;;IAkBsB,kBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { createClient } from '@/utils/supabase/server'\r\nimport { revalidatePath } from 'next/cache'\r\n\r\nexport type ApprovalGroupNode = {\r\n  id: string;\r\n  group_name: string;\r\n  next_approver_group_id: string | null;\r\n  company_id: string;\r\n  is_final_authority: boolean;\r\n  role_count?: number; // We'll fetch how many roles are in this group\r\n}\r\n\r\n/**\r\n * Fetches the flat list of groups for a company.\r\n * The visualizer will reconstruct the tree from this flat list.\r\n */\r\nexport async function getCompanyChain(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // 1. Fetch groups for the company\r\n  const { data: companyGroups, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, \r\n      group_name, \r\n      next_approver_group_id, \r\n      company_id, \r\n      is_final_authority,\r\n      roles:roles(count)\r\n    `)\r\n    .eq('company_id', companyId)\r\n\r\n  if (error) {\r\n    console.error('Error fetching chain:', error)\r\n    return []\r\n  }\r\n\r\n  // 2. Flatten the count\r\n  // (Supabase returns { count: 5 } array, we just want the number)\r\n  const formattedGroups = companyGroups.map(g => ({\r\n    ...g,\r\n    role_count: g.roles ? (g.roles as any)[0]?.count || 0 : 0\r\n  })) as ApprovalGroupNode[]\r\n\r\n  // 3. Fetch the \"Final Authority\" groups (Commandant/Battalion) \r\n  // We need these to show the end of the chain, even if they belong to a different company\r\n  // We find them by looking at the 'next_approver_group_id' of the top-level company groups\r\n  const outgoingLinkIds = formattedGroups\r\n    .map(g => g.next_approver_group_id)\r\n    .filter(id => id !== null) as string[];\r\n    \r\n  // If an outgoing link points to a group NOT in our fetched list, fetch it now\r\n  const existingIds = new Set(formattedGroups.map(g => g.id));\r\n  const missingIds = outgoingLinkIds.filter(id => !existingIds.has(id));\r\n\r\n  if (missingIds.length > 0) {\r\n    const { data: externalGroups } = await supabase\r\n      .from('approval_groups')\r\n      .select('id, group_name, next_approver_group_id, company_id, is_final_authority')\r\n      .in('id', missingIds);\r\n\r\n    if (externalGroups) {\r\n        // Add external nodes (like Commandant Staff) to the list so we can render them\r\n        formattedGroups.push(...(externalGroups as any[]));\r\n    }\r\n  }\r\n\r\n  return formattedGroups;\r\n}\r\n\r\n/**\r\n * INSERT LOGIC:\r\n * User selects \"Who does this new group approve?\" (Child Group).\r\n * We insert the New Group *between* the Child and the Child's current approver.\r\n */\r\nexport async function createGroupAction(\r\n  companyId: string, \r\n  groupName: string, \r\n  childGroupIdToApprove: string // The group that will report TO this new group\r\n) {\r\n  const supabase = createClient()\r\n\r\n  // 1. Get the Child Group to see who it currently points to\r\n  const { data: childGroup, error: fetchError } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', childGroupIdToApprove)\r\n    .single();\r\n\r\n  if (fetchError || !childGroup) return { error: \"Could not find the group you selected to approve.\" };\r\n\r\n  const oldParentId = childGroup.next_approver_group_id;\r\n\r\n  // 2. Create the New Group\r\n  // Point it to the Child's OLD parent (or null if Child was top)\r\n  const { data: newGroup, error: createError } = await supabase\r\n    .from('approval_groups')\r\n    .insert({\r\n      group_name: groupName,\r\n      company_id: companyId,\r\n      next_approver_group_id: oldParentId,\r\n      is_final_authority: false\r\n    })\r\n    .select('id')\r\n    .single();\r\n\r\n  if (createError) return { error: createError.message };\r\n\r\n  // 3. Update the Child Group\r\n  // Point it to the NEW group\r\n  const { error: updateError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ next_approver_group_id: newGroup.id })\r\n    .eq('id', childGroupIdToApprove);\r\n\r\n  if (updateError) return { error: \"Failed to re-link the chain.\" };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n/**\r\n * DELETE LOGIC:\r\n * 1. Find who the target group points to (Parent).\r\n * 2. Find everyone pointing TO the target group (Children).\r\n * 3. Point all Children to the Parent.\r\n * 4. Delete the target.\r\n */\r\nexport async function deleteGroupAction(groupId: string) {\r\n  const supabase = createClient()\r\n\r\n  // 1. Get Target info\r\n  const { data: targetGroup } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', groupId)\r\n    .single();\r\n  \r\n  if (!targetGroup) return { error: \"Group not found\" };\r\n\r\n  const parentId = targetGroup.next_approver_group_id;\r\n\r\n  // 2. Re-link children (Update Step)\r\n  const { error: relinkError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ next_approver_group_id: parentId })\r\n    .eq('next_approver_group_id', groupId); // Find anyone pointing to ME\r\n\r\n  if (relinkError) return { error: \"Failed to re-link children groups.\" };\r\n\r\n  // 3. Delete the group\r\n  const { error: deleteError } = await supabase\r\n    .from('approval_groups')\r\n    .delete()\r\n    .eq('id', groupId);\r\n\r\n  if (deleteError) return { error: deleteError.message };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n// ... existing imports and code\r\n\r\n// --- ROLE MANAGEMENT ---\r\n\r\nexport async function getGroupRoles(groupId: string) {\r\n  const supabase = createClient()\r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('approval_group_id', groupId)\r\n    .order('role_name')\r\n  \r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\nexport async function deleteRoleAction(roleId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // Security check: ensure no users are assigned? \r\n  // For now, we'll just delete. Supabase might throw FK error if used.\r\n  const { error } = await supabase.from('roles').delete().eq('id', roleId)\r\n  \r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}\r\n\r\nexport async function createRoleAction(\r\n  companyId: string,\r\n  groupId: string,\r\n  roleName: string,\r\n  defaultLevel: number\r\n) {\r\n  const supabase = createClient()\r\n\r\n  const { error } = await supabase.from('roles').insert({\r\n    company_id: companyId,\r\n    approval_group_id: groupId,\r\n    role_name: roleName,\r\n    default_role_level: defaultLevel,\r\n    can_manage_own_company_roster: defaultLevel >= 40, // Basic logic\r\n    can_manage_all_rosters: defaultLevel >= 50\r\n  })\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}"],"names":[],"mappings":";;;;;;;IAkIsB,oBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/components/GroupNode.tsx"],"sourcesContent":["// app/manage/roles/components/GroupNode.tsx\r\nimport { ApprovalGroupNode } from '../actions'\r\n\r\ninterface GroupNodeProps {\r\n  node: ApprovalGroupNode\r\n  onDelete: () => void\r\n  onAddParent: () => void // Called when we want to insert a node that this node reports TO\r\n}\r\n\r\nexport default function GroupNode({ node, onDelete, onAddParent }: GroupNodeProps) {\r\n  \r\n  const isFinal = node.is_final_authority\r\n  \r\n  return (\r\n    <div className=\"relative group flex items-center\">\r\n      \r\n      {/* The Box */}\r\n      <div className={`\r\n        relative w-64 p-4 rounded-lg border-2 shadow-md transition-all hover:shadow-lg bg-white dark:bg-gray-800\r\n        ${isFinal ? 'border-yellow-500 dark:border-yellow-500 ring-2 ring-yellow-100 dark:ring-yellow-900/30' : 'border-gray-200 dark:border-gray-700'}\r\n      `}>\r\n        \r\n        {/* Header */}\r\n        <div className=\"flex justify-between items-start mb-2\">\r\n          <h3 className=\"font-bold text-gray-900 dark:text-white text-sm leading-tight\">\r\n            {node.group_name}\r\n          </h3>\r\n          {/* Delete Button (Only show if not final/external) */}\r\n          {!isFinal && (\r\n             <button \r\n               onClick={onDelete}\r\n               className=\"text-gray-400 hover:text-red-600 transition-colors opacity-0 group-hover:opacity-100\"\r\n               title=\"Delete Group\"\r\n             >\r\n               <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" /></svg>\r\n             </button>\r\n          )}\r\n        </div>\r\n\r\n        {/* Stats */}\r\n        <div className=\"text-xs text-gray-500 dark:text-gray-400 flex gap-2\">\r\n          <span>Roles: {node.role_count || 0}</span>\r\n          {isFinal && <span className=\"text-yellow-600 font-semibold ml-auto\">Final Authority</span>}\r\n        </div>\r\n\r\n        {/* Insert Button (The \"Link\" connector) */}\r\n        {/* Only show insert button if it's NOT the final authority (can't insert after final) */}\r\n        {!isFinal && (\r\n          <div className=\"absolute -right-5 top-1/2 -translate-y-1/2 z-10\">\r\n             <button \r\n               onClick={onAddParent}\r\n               className=\"flex items-center justify-center w-8 h-8 bg-indigo-600 text-white rounded-full shadow hover:bg-indigo-700 hover:scale-110 transition-all border-2 border-white dark:border-gray-900\"\r\n               title=\"Insert Approval Level\"\r\n             >\r\n               <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 4v16m8-8H4\" /></svg>\r\n             </button>\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* Connection Line (Visual only) */}\r\n      {!isFinal && (\r\n        <div className=\"w-6 h-0.5 bg-gray-300 dark:bg-gray-600 mx-2\"></div>\r\n      )}\r\n    </div>\r\n  )\r\n}"],"names":[],"mappings":"AAAA,4CAA4C;;;;;;;AAS7B,SAAS,UAAU,EAAE,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAkB;IAE/E,MAAM,UAAU,KAAK,kBAAkB;IAEvC,qBACE,6LAAC;QAAI,WAAU;;0BAGb,6LAAC;gBAAI,WAAW,CAAC;;QAEf,EAAE,UAAU,4FAA4F,uCAAuC;MACjJ,CAAC;;kCAGC,6LAAC;wBAAI,WAAU;;0CACb,6LAAC;gCAAG,WAAU;0CACX,KAAK,UAAU;;;;;;4BAGjB,CAAC,yBACC,6LAAC;gCACC,SAAS;gCACT,WAAU;gCACV,OAAM;0CAEN,cAAA,6LAAC;oCAAI,WAAU;oCAAU,MAAK;oCAAO,QAAO;oCAAe,SAAQ;8CAAY,cAAA,6LAAC;wCAAK,eAAc;wCAAQ,gBAAe;wCAAQ,aAAa;wCAAG,GAAE;;;;;;;;;;;;;;;;;;;;;;kCAM3J,6LAAC;wBAAI,WAAU;;0CACb,6LAAC;;oCAAK;oCAAQ,KAAK,UAAU,IAAI;;;;;;;4BAChC,yBAAW,6LAAC;gCAAK,WAAU;0CAAwC;;;;;;;;;;;;oBAKrE,CAAC,yBACA,6LAAC;wBAAI,WAAU;kCACZ,cAAA,6LAAC;4BACC,SAAS;4BACT,WAAU;4BACV,OAAM;sCAEN,cAAA,6LAAC;gCAAI,WAAU;gCAAU,MAAK;gCAAO,QAAO;gCAAe,SAAQ;0CAAY,cAAA,6LAAC;oCAAK,eAAc;oCAAQ,gBAAe;oCAAQ,aAAa;oCAAG,GAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;YAO5J,CAAC,yBACA,6LAAC;gBAAI,WAAU;;;;;;;;;;;;AAIvB;KAzDwB","debugId":null}},
    {"offset": {"line": 191, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { createClient } from '@/utils/supabase/server'\r\nimport { revalidatePath } from 'next/cache'\r\n\r\nexport type ApprovalGroupNode = {\r\n  id: string;\r\n  group_name: string;\r\n  next_approver_group_id: string | null;\r\n  company_id: string;\r\n  is_final_authority: boolean;\r\n  role_count?: number; // We'll fetch how many roles are in this group\r\n}\r\n\r\n/**\r\n * Fetches the flat list of groups for a company.\r\n * The visualizer will reconstruct the tree from this flat list.\r\n */\r\nexport async function getCompanyChain(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // 1. Fetch groups for the company\r\n  const { data: companyGroups, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, \r\n      group_name, \r\n      next_approver_group_id, \r\n      company_id, \r\n      is_final_authority,\r\n      roles:roles(count)\r\n    `)\r\n    .eq('company_id', companyId)\r\n\r\n  if (error) {\r\n    console.error('Error fetching chain:', error)\r\n    return []\r\n  }\r\n\r\n  // 2. Flatten the count\r\n  // (Supabase returns { count: 5 } array, we just want the number)\r\n  const formattedGroups = companyGroups.map(g => ({\r\n    ...g,\r\n    role_count: g.roles ? (g.roles as any)[0]?.count || 0 : 0\r\n  })) as ApprovalGroupNode[]\r\n\r\n  // 3. Fetch the \"Final Authority\" groups (Commandant/Battalion) \r\n  // We need these to show the end of the chain, even if they belong to a different company\r\n  // We find them by looking at the 'next_approver_group_id' of the top-level company groups\r\n  const outgoingLinkIds = formattedGroups\r\n    .map(g => g.next_approver_group_id)\r\n    .filter(id => id !== null) as string[];\r\n    \r\n  // If an outgoing link points to a group NOT in our fetched list, fetch it now\r\n  const existingIds = new Set(formattedGroups.map(g => g.id));\r\n  const missingIds = outgoingLinkIds.filter(id => !existingIds.has(id));\r\n\r\n  if (missingIds.length > 0) {\r\n    const { data: externalGroups } = await supabase\r\n      .from('approval_groups')\r\n      .select('id, group_name, next_approver_group_id, company_id, is_final_authority')\r\n      .in('id', missingIds);\r\n\r\n    if (externalGroups) {\r\n        // Add external nodes (like Commandant Staff) to the list so we can render them\r\n        formattedGroups.push(...(externalGroups as any[]));\r\n    }\r\n  }\r\n\r\n  return formattedGroups;\r\n}\r\n\r\n/**\r\n * INSERT LOGIC:\r\n * User selects \"Who does this new group approve?\" (Child Group).\r\n * We insert the New Group *between* the Child and the Child's current approver.\r\n */\r\nexport async function createGroupAction(\r\n  companyId: string, \r\n  groupName: string, \r\n  childGroupIdToApprove: string // The group that will report TO this new group\r\n) {\r\n  const supabase = createClient()\r\n\r\n  // 1. Get the Child Group to see who it currently points to\r\n  const { data: childGroup, error: fetchError } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', childGroupIdToApprove)\r\n    .single();\r\n\r\n  if (fetchError || !childGroup) return { error: \"Could not find the group you selected to approve.\" };\r\n\r\n  const oldParentId = childGroup.next_approver_group_id;\r\n\r\n  // 2. Create the New Group\r\n  // Point it to the Child's OLD parent (or null if Child was top)\r\n  const { data: newGroup, error: createError } = await supabase\r\n    .from('approval_groups')\r\n    .insert({\r\n      group_name: groupName,\r\n      company_id: companyId,\r\n      next_approver_group_id: oldParentId,\r\n      is_final_authority: false\r\n    })\r\n    .select('id')\r\n    .single();\r\n\r\n  if (createError) return { error: createError.message };\r\n\r\n  // 3. Update the Child Group\r\n  // Point it to the NEW group\r\n  const { error: updateError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ next_approver_group_id: newGroup.id })\r\n    .eq('id', childGroupIdToApprove);\r\n\r\n  if (updateError) return { error: \"Failed to re-link the chain.\" };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n/**\r\n * DELETE LOGIC:\r\n * 1. Find who the target group points to (Parent).\r\n * 2. Find everyone pointing TO the target group (Children).\r\n * 3. Point all Children to the Parent.\r\n * 4. Delete the target.\r\n */\r\nexport async function deleteGroupAction(groupId: string) {\r\n  const supabase = createClient()\r\n\r\n  // 1. Get Target info\r\n  const { data: targetGroup } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', groupId)\r\n    .single();\r\n  \r\n  if (!targetGroup) return { error: \"Group not found\" };\r\n\r\n  const parentId = targetGroup.next_approver_group_id;\r\n\r\n  // 2. Re-link children (Update Step)\r\n  const { error: relinkError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ next_approver_group_id: parentId })\r\n    .eq('next_approver_group_id', groupId); // Find anyone pointing to ME\r\n\r\n  if (relinkError) return { error: \"Failed to re-link children groups.\" };\r\n\r\n  // 3. Delete the group\r\n  const { error: deleteError } = await supabase\r\n    .from('approval_groups')\r\n    .delete()\r\n    .eq('id', groupId);\r\n\r\n  if (deleteError) return { error: deleteError.message };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n// ... existing imports and code\r\n\r\n// --- ROLE MANAGEMENT ---\r\n\r\nexport async function getGroupRoles(groupId: string) {\r\n  const supabase = createClient()\r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('approval_group_id', groupId)\r\n    .order('role_name')\r\n  \r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\nexport async function deleteRoleAction(roleId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // Security check: ensure no users are assigned? \r\n  // For now, we'll just delete. Supabase might throw FK error if used.\r\n  const { error } = await supabase.from('roles').delete().eq('id', roleId)\r\n  \r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}\r\n\r\nexport async function createRoleAction(\r\n  companyId: string,\r\n  groupId: string,\r\n  roleName: string,\r\n  defaultLevel: number\r\n) {\r\n  const supabase = createClient()\r\n\r\n  const { error } = await supabase.from('roles').insert({\r\n    company_id: companyId,\r\n    approval_group_id: groupId,\r\n    role_name: roleName,\r\n    default_role_level: defaultLevel,\r\n    can_manage_own_company_roster: defaultLevel >= 40, // Basic logic\r\n    can_manage_all_rosters: defaultLevel >= 50\r\n  })\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}"],"names":[],"mappings":";;;;;;;IA6EsB,oBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 206, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/components/AddGroupModal.tsx"],"sourcesContent":["// app/manage/roles/components/AddGroupModal.tsx\r\n'use client'\r\nimport { useState } from 'react'\r\nimport { createGroupAction } from '../actions'\r\n\r\ninterface AddGroupModalProps {\r\n  isOpen: boolean\r\n  onClose: () => void\r\n  companyId: string\r\n  childGroupId: string // The group that will report TO this new group\r\n  onSuccess: () => void\r\n}\r\n\r\nexport default function AddGroupModal({ isOpen, onClose, companyId, childGroupId, onSuccess }: AddGroupModalProps) {\r\n  const [name, setName] = useState('')\r\n  const [loading, setLoading] = useState(false)\r\n\r\n  const handleSubmit = async (e: React.FormEvent) => {\r\n    e.preventDefault()\r\n    if (!name.trim()) return\r\n    \r\n    setLoading(true)\r\n    const result = await createGroupAction(companyId, name, childGroupId)\r\n    setLoading(false)\r\n\r\n    if (result?.error) {\r\n      alert(result.error)\r\n    } else {\r\n      onSuccess()\r\n    }\r\n  }\r\n\r\n  if (!isOpen) return null\r\n\r\n  return (\r\n    <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm\">\r\n      <div className=\"bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl w-96 border dark:border-gray-700\">\r\n        <h2 className=\"text-lg font-bold mb-4 text-gray-900 dark:text-white\">Insert Approval Step</h2>\r\n        <p className=\"text-sm text-gray-500 mb-4\">\r\n          This new group will approve reports coming from the selected group, and then forward them up the existing chain.\r\n        </p>\r\n        \r\n        <form onSubmit={handleSubmit}>\r\n          <div className=\"mb-4\">\r\n            <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">Group Name</label>\r\n            <input \r\n              type=\"text\" \r\n              value={name} \r\n              onChange={e => setName(e.target.value)}\r\n              placeholder=\"e.g. Platoon Sergeant\"\r\n              className=\"w-full rounded-md border-gray-300 dark:border-gray-600 dark:bg-gray-900 dark:text-white p-2\"\r\n              autoFocus\r\n            />\r\n          </div>\r\n\r\n          <div className=\"flex justify-end gap-2\">\r\n            <button type=\"button\" onClick={onClose} className=\"px-3 py-1.5 text-sm text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded\">Cancel</button>\r\n            <button \r\n              type=\"submit\" \r\n              disabled={loading || !name.trim()}\r\n              className=\"px-3 py-1.5 text-sm bg-indigo-600 text-white rounded hover:bg-indigo-700 disabled:opacity-50\"\r\n            >\r\n              {loading ? 'Saving...' : 'Create & Insert'}\r\n            </button>\r\n          </div>\r\n        </form>\r\n      </div>\r\n    </div>\r\n  )\r\n}"],"names":[],"mappings":"AAAA,gDAAgD;;;;;;AAEhD;AACA;;;AAFA;;;AAYe,SAAS,cAAc,EAAE,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,YAAY,EAAE,SAAS,EAAsB;;IAC/G,MAAM,CAAC,MAAM,QAAQ,GAAG,IAAA,yKAAQ,EAAC;IACjC,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,yKAAQ,EAAC;IAEvC,MAAM,eAAe,OAAO;QAC1B,EAAE,cAAc;QAChB,IAAI,CAAC,KAAK,IAAI,IAAI;QAElB,WAAW;QACX,MAAM,SAAS,MAAM,IAAA,sLAAiB,EAAC,WAAW,MAAM;QACxD,WAAW;QAEX,IAAI,QAAQ,OAAO;YACjB,MAAM,OAAO,KAAK;QACpB,OAAO;YACL;QACF;IACF;IAEA,IAAI,CAAC,QAAQ,OAAO;IAEpB,qBACE,6LAAC;QAAI,WAAU;kBACb,cAAA,6LAAC;YAAI,WAAU;;8BACb,6LAAC;oBAAG,WAAU;8BAAuD;;;;;;8BACrE,6LAAC;oBAAE,WAAU;8BAA6B;;;;;;8BAI1C,6LAAC;oBAAK,UAAU;;sCACd,6LAAC;4BAAI,WAAU;;8CACb,6LAAC;oCAAM,WAAU;8CAAkE;;;;;;8CACnF,6LAAC;oCACC,MAAK;oCACL,OAAO;oCACP,UAAU,CAAA,IAAK,QAAQ,EAAE,MAAM,CAAC,KAAK;oCACrC,aAAY;oCACZ,WAAU;oCACV,SAAS;;;;;;;;;;;;sCAIb,6LAAC;4BAAI,WAAU;;8CACb,6LAAC;oCAAO,MAAK;oCAAS,SAAS;oCAAS,WAAU;8CAAwG;;;;;;8CAC1J,6LAAC;oCACC,MAAK;oCACL,UAAU,WAAW,CAAC,KAAK,IAAI;oCAC/B,WAAU;8CAET,UAAU,cAAc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOvC;GAxDwB;KAAA","debugId":null}},
    {"offset": {"line": 347, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/components/ChainVisualizer.tsx"],"sourcesContent":["// app/manage/roles/components/ChainVisualizer.tsx\r\n'use client'\r\n\r\nimport { useState, useEffect, useMemo } from 'react'\r\nimport { getCompanyChain, deleteGroupAction, createGroupAction, type ApprovalGroupNode } from '../actions'\r\nimport GroupNode from './GroupNode'\r\nimport AddGroupModal from './AddGroupModal' // We will create this next\r\nimport RoleListModal from './RoleListModal'\r\n\r\ninterface ChainVisualizerProps {\r\n  initialCompanies: { id: string; company_name: string }[]\r\n}\r\n\r\nexport default function ChainVisualizer({ initialCompanies }: ChainVisualizerProps) {\r\n  const [selectedCompanyId, setSelectedCompanyId] = useState(initialCompanies[0]?.id || '')\r\n  const [nodes, setNodes] = useState<ApprovalGroupNode[]>([])\r\n  const [loading, setLoading] = useState(false)\r\n  \r\n  \r\n  // Modal State\r\n  const [isAddModalOpen, setIsAddModalOpen] = useState(false)\r\n  const [targetChildId, setTargetChildId] = useState<string | null>(null) // The node that will report TO the new node\r\n  const [selectedNodeForRoles, setSelectedNodeForRoles] = useState<ApprovalGroupNode | null>(null)\r\n\r\n  // 1. Fetch Chain Data when Company Changes\r\n  useEffect(() => {\r\n    if (!selectedCompanyId) return\r\n    fetchChain()\r\n  }, [selectedCompanyId])\r\n\r\n  async function fetchChain() {\r\n    setLoading(true)\r\n    const data = await getCompanyChain(selectedCompanyId)\r\n    setNodes(data)\r\n    setLoading(false)\r\n  }\r\n\r\n  // 2. Actions\r\n  const handleDelete = async (id: string) => {\r\n    if (!confirm(\"Delete this group? Any groups pointing to it will be moved to its approver.\")) return\r\n    await deleteGroupAction(id)\r\n    fetchChain() // Refresh\r\n  }\r\n\r\n  const handleOpenAdd = (childId: string) => {\r\n    setTargetChildId(childId)\r\n    setIsAddModalOpen(true)\r\n  }\r\n\r\n  const handleNodeClick = (node: ApprovalGroupNode) => {\r\n  setSelectedNodeForRoles(node)\r\n}\r\n\r\n  // 3. Layout Algorithm (The \"Inverted Tree\")\r\n  // We organize nodes into columns based on how far they are from the \"Final Authority\"\r\n  const columns = useMemo(() => {\r\n    if (nodes.length === 0) return []\r\n\r\n    const depthMap = new Map<string, number>()\r\n    const adjacency = new Map<string, string[]>() // Parent -> [Children]\r\n\r\n    // Build Adjacency List (Who points to whom?)\r\n    nodes.forEach(node => {\r\n      const parent = node.next_approver_group_id || 'ROOT'\r\n      if (!adjacency.has(parent)) adjacency.set(parent, [])\r\n      adjacency.get(parent)?.push(node.id)\r\n    })\r\n\r\n    // Recursive function to determine depth (Right-to-Left)\r\n    // 0 = Final Authority\r\n    // 1 = Reports to Final\r\n    // 2 = Reports to Tier 1...\r\n    function assignDepth(nodeId: string, currentDepth: number) {\r\n      const children = adjacency.get(nodeId) || []\r\n      children.forEach(childId => {\r\n        depthMap.set(childId, currentDepth + 1) // Children are \"deeper\" (further left)\r\n        assignDepth(childId, currentDepth + 1)\r\n      })\r\n    }\r\n\r\n    // Find the roots (Nodes that either point to nothing, or point to a node NOT in this list)\r\n    // In our data, the Commandant Staff is usually the root.\r\n    // We look for 'ROOT' keys in our adjacency map from step 1.\r\n    const rootChildren = adjacency.get('ROOT') || []\r\n    \r\n    // However, if the chain leaves the company, the \"Parent\" might exist in the nodes list.\r\n    // We iterate the 'Final Authority' nodes first.\r\n    const finalNodes = nodes.filter(n => n.is_final_authority || !n.next_approver_group_id)\r\n    \r\n    finalNodes.forEach(node => {\r\n      depthMap.set(node.id, 0)\r\n      assignDepth(node.id, 0)\r\n    })\r\n\r\n    // Group by Depth\r\n    const maxDepth = Math.max(...Array.from(depthMap.values()), 0)\r\n    const cols: ApprovalGroupNode[][] = Array.from({ length: maxDepth + 1 }, () => [])\r\n\r\n    nodes.forEach(node => {\r\n      const depth = depthMap.get(node.id)\r\n      if (depth !== undefined) {\r\n        cols[depth].push(node)\r\n      }\r\n    })\r\n\r\n    // Reverse so \"Final\" (Depth 0) is on the Right\r\n    return cols.reverse()\r\n  }, [nodes])\r\n\r\n\r\n  return (\r\n    <div className=\"space-y-6\">\r\n      {/* --- TOOLBAR --- */}\r\n      <div className=\"flex items-center gap-4 bg-white dark:bg-gray-800 p-4 rounded-lg shadow\">\r\n        <label className=\"font-medium text-gray-700 dark:text-gray-300\">Select Company:</label>\r\n        <select \r\n          value={selectedCompanyId} \r\n          onChange={(e) => setSelectedCompanyId(e.target.value)}\r\n          className=\"rounded-md border-gray-300 dark:border-gray-600 dark:bg-gray-900\"\r\n        >\r\n          {initialCompanies.map(c => <option key={c.id} value={c.id}>{c.company_name}</option>)}\r\n        </select>\r\n        <button onClick={fetchChain} className=\"ml-auto text-sm text-indigo-600 hover:underline\">Refresh</button>\r\n      </div>\r\n\r\n      {/* --- VISUALIZATION CANVAS --- */}\r\n      <div className=\"overflow-x-auto pb-8 min-h-[600px] bg-gray-50 dark:bg-gray-900/50 rounded-xl border dark:border-gray-700 p-8\">\r\n        {loading ? (\r\n          <div className=\"flex items-center justify-center h-64 text-gray-500\">Loading Chain...</div>\r\n        ) : (\r\n          <div className=\"flex gap-12 min-w-max items-center\">\r\n            \r\n            {/* Render Columns */}\r\n            {columns.map((col, colIndex) => (\r\n              <div key={colIndex} className=\"flex flex-col gap-6 justify-center\">\r\n                {/* Column Header (Optional) */}\r\n                <div className=\"text-center text-xs font-bold text-gray-400 uppercase tracking-wider mb-2\">\r\n                  {colIndex === columns.length - 1 ? \"Final Approval\" : `Step ${columns.length - 1 - colIndex}`}\r\n                </div>\r\n\r\n                {/* Find the GroupNode mapping and update props */}\r\n                {col.map(node => (\r\n                <div key={node.id} onClick={() => handleNodeClick(node)} className=\"cursor-pointer\"> {/* Wrap in div for click */}\r\n                    <GroupNode \r\n                    node={node} \r\n                    onDelete={(e) => { e.stopPropagation(); handleDelete(node.id); }} // Prevent opening modal on delete\r\n                    onAddParent={(e) => { e.stopPropagation(); handleOpenAdd(node.id); }} // Prevent opening modal on add\r\n                    />\r\n                </div>\r\n                ))}\r\n              </div>\r\n            ))}\r\n            \r\n            {columns.length === 0 && (\r\n               <div className=\"text-gray-500\">No approval groups found for this company.</div>\r\n            )}\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* --- MODAL --- */}\r\n      {isAddModalOpen && targetChildId && (\r\n        <AddGroupModal \r\n          isOpen={isAddModalOpen}\r\n          onClose={() => setIsAddModalOpen(false)}\r\n          companyId={selectedCompanyId}\r\n          childGroupId={targetChildId}\r\n          onSuccess={() => {\r\n            setIsAddModalOpen(false)\r\n            fetchChain()\r\n          }}\r\n        />\r\n      )}\r\n    </div>\r\n  )\r\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 620, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/node_modules/next/src/build/webpack/loaders/next-flight-loader/action-client-wrapper.ts"],"sourcesContent":["// This file must be bundled in the app's client layer, it shouldn't be directly\n// imported by the server.\n\nexport { callServer } from 'next/dist/client/app-call-server'\nexport { findSourceMapURL } from 'next/dist/client/app-find-source-map-url'\n\n// A noop wrapper to let the Flight client create the server reference.\n// See also: https://github.com/facebook/react/pull/26632\n// eslint-disable-next-line import/no-extraneous-dependencies\nexport { createServerReference } from 'react-server-dom-webpack/client'\n"],"names":["callServer","createServerReference","findSourceMapURL"],"mappings":"AAAA,gFAAgF;AAChF,0BAA0B;;;;;;;;;;;;;;;;IAEjBA,UAAU,EAAA;eAAVA,eAAAA,UAAU;;IAMVC,qBAAqB,EAAA;eAArBA,QAAAA,qBAAqB;;IALrBC,gBAAgB,EAAA;eAAhBA,qBAAAA,gBAAgB;;;+BADE;qCACM;wBAKK","ignoreList":[0],"debugId":null}}]
}