{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { createClient } from '@/utils/supabase/server'\r\nimport { revalidatePath } from 'next/cache'\r\n\r\nexport type ApprovalGroupNode = {\r\n  id: string;\r\n  group_name: string;\r\n  next_approver_group_id: string | null;\r\n  company_id: string;\r\n  is_final_authority: boolean;\r\n  role_count?: number; // We'll fetch how many roles are in this group\r\n}\r\n\r\n/**\r\n * Fetches the flat list of groups for a company.\r\n * The visualizer will reconstruct the tree from this flat list.\r\n */\r\nexport async function getCompanyChain(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // 1. Fetch groups for the company\r\n  const { data: companyGroups, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, \r\n      group_name, \r\n      next_approver_group_id, \r\n      company_id, \r\n      is_final_authority,\r\n      roles:roles(count)\r\n    `)\r\n    .eq('company_id', companyId)\r\n\r\n  if (error) {\r\n    console.error('Error fetching chain:', error)\r\n    return []\r\n  }\r\n\r\n  // 2. Flatten the count\r\n  // (Supabase returns { count: 5 } array, we just want the number)\r\n  const formattedGroups = companyGroups.map(g => ({\r\n    ...g,\r\n    role_count: g.roles ? (g.roles as any)[0]?.count || 0 : 0\r\n  })) as ApprovalGroupNode[]\r\n\r\n  // 3. Fetch the \"Final Authority\" groups (Commandant/Battalion) \r\n  // We need these to show the end of the chain, even if they belong to a different company\r\n  // We find them by looking at the 'next_approver_group_id' of the top-level company groups\r\n  const outgoingLinkIds = formattedGroups\r\n    .map(g => g.next_approver_group_id)\r\n    .filter(id => id !== null) as string[];\r\n    \r\n  // If an outgoing link points to a group NOT in our fetched list, fetch it now\r\n  const existingIds = new Set(formattedGroups.map(g => g.id));\r\n  const missingIds = outgoingLinkIds.filter(id => !existingIds.has(id));\r\n\r\n  if (missingIds.length > 0) {\r\n    const { data: externalGroups } = await supabase\r\n      .from('approval_groups')\r\n      .select('id, group_name, next_approver_group_id, company_id, is_final_authority')\r\n      .in('id', missingIds);\r\n\r\n    if (externalGroups) {\r\n        // Add external nodes (like Commandant Staff) to the list so we can render them\r\n        formattedGroups.push(...(externalGroups as any[]));\r\n    }\r\n  }\r\n\r\n  return formattedGroups;\r\n}\r\n\r\n/**\r\n * INSERT LOGIC:\r\n * User selects \"Who does this new group approve?\" (Child Group).\r\n * We insert the New Group *between* the Child and the Child's current approver.\r\n */\r\nexport async function createGroupAction(\r\n  companyId: string, \r\n  groupName: string, \r\n  childGroupIdToApprove: string // The group that will report TO this new group\r\n) {\r\n  const supabase = createClient()\r\n\r\n  // 1. Get the Child Group to see who it currently points to\r\n  const { data: childGroup, error: fetchError } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', childGroupIdToApprove)\r\n    .single();\r\n\r\n  if (fetchError || !childGroup) return { error: \"Could not find the group you selected to approve.\" };\r\n\r\n  const oldParentId = childGroup.next_approver_group_id;\r\n\r\n  // 2. Create the New Group\r\n  // Point it to the Child's OLD parent (or null if Child was top)\r\n  const { data: newGroup, error: createError } = await supabase\r\n    .from('approval_groups')\r\n    .insert({\r\n      group_name: groupName,\r\n      company_id: companyId,\r\n      next_approver_group_id: oldParentId,\r\n      is_final_authority: false\r\n    })\r\n    .select('id')\r\n    .single();\r\n\r\n  if (createError) return { error: createError.message };\r\n\r\n  // 3. Update the Child Group\r\n  // Point it to the NEW group\r\n  const { error: updateError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ next_approver_group_id: newGroup.id })\r\n    .eq('id', childGroupIdToApprove);\r\n\r\n  if (updateError) return { error: \"Failed to re-link the chain.\" };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n/**\r\n * DELETE LOGIC:\r\n * 1. Find who the target group points to (Parent).\r\n * 2. Find everyone pointing TO the target group (Children).\r\n * 3. Point all Children to the Parent.\r\n * 4. Delete the target.\r\n */\r\nexport async function deleteGroupAction(groupId: string) {\r\n  const supabase = createClient()\r\n\r\n  // 1. Get Target info\r\n  const { data: targetGroup } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', groupId)\r\n    .single();\r\n  \r\n  if (!targetGroup) return { error: \"Group not found\" };\r\n\r\n  const parentId = targetGroup.next_approver_group_id;\r\n\r\n  // 2. Re-link children (Update Step)\r\n  const { error: relinkError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ next_approver_group_id: parentId })\r\n    .eq('next_approver_group_id', groupId); // Find anyone pointing to ME\r\n\r\n  if (relinkError) return { error: \"Failed to re-link children groups.\" };\r\n\r\n  // 3. Delete the group\r\n  const { error: deleteError } = await supabase\r\n    .from('approval_groups')\r\n    .delete()\r\n    .eq('id', groupId);\r\n\r\n  if (deleteError) return { error: deleteError.message };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n// ... existing imports and code\r\n\r\n// --- ROLE MANAGEMENT ---\r\n\r\nexport async function getGroupRoles(groupId: string) {\r\n  const supabase = createClient()\r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('approval_group_id', groupId)\r\n    .order('role_name')\r\n  \r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\nexport async function deleteRoleAction(roleId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // Security check: ensure no users are assigned? \r\n  // For now, we'll just delete. Supabase might throw FK error if used.\r\n  const { error } = await supabase.from('roles').delete().eq('id', roleId)\r\n  \r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}\r\n\r\nexport async function createRoleAction(\r\n  companyId: string,\r\n  groupId: string,\r\n  roleName: string,\r\n  defaultLevel: number\r\n) {\r\n  const supabase = createClient()\r\n\r\n  const { error } = await supabase.from('roles').insert({\r\n    company_id: companyId,\r\n    approval_group_id: groupId,\r\n    role_name: roleName,\r\n    default_role_level: defaultLevel,\r\n    can_manage_own_company_roster: defaultLevel >= 40, // Basic logic\r\n    can_manage_all_rosters: defaultLevel >= 50\r\n  })\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}"],"names":[],"mappings":";;;;;;;IAkBsB,kBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA","debugId":null}},
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { createClient } from '@/utils/supabase/server'\r\nimport { revalidatePath } from 'next/cache'\r\n\r\nexport type ApprovalGroupNode = {\r\n  id: string;\r\n  group_name: string;\r\n  next_approver_group_id: string | null;\r\n  company_id: string;\r\n  is_final_authority: boolean;\r\n  role_count?: number; // We'll fetch how many roles are in this group\r\n}\r\n\r\n/**\r\n * Fetches the flat list of groups for a company.\r\n * The visualizer will reconstruct the tree from this flat list.\r\n */\r\nexport async function getCompanyChain(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // 1. Fetch groups for the company\r\n  const { data: companyGroups, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, \r\n      group_name, \r\n      next_approver_group_id, \r\n      company_id, \r\n      is_final_authority,\r\n      roles:roles(count)\r\n    `)\r\n    .eq('company_id', companyId)\r\n\r\n  if (error) {\r\n    console.error('Error fetching chain:', error)\r\n    return []\r\n  }\r\n\r\n  // 2. Flatten the count\r\n  // (Supabase returns { count: 5 } array, we just want the number)\r\n  const formattedGroups = companyGroups.map(g => ({\r\n    ...g,\r\n    role_count: g.roles ? (g.roles as any)[0]?.count || 0 : 0\r\n  })) as ApprovalGroupNode[]\r\n\r\n  // 3. Fetch the \"Final Authority\" groups (Commandant/Battalion) \r\n  // We need these to show the end of the chain, even if they belong to a different company\r\n  // We find them by looking at the 'next_approver_group_id' of the top-level company groups\r\n  const outgoingLinkIds = formattedGroups\r\n    .map(g => g.next_approver_group_id)\r\n    .filter(id => id !== null) as string[];\r\n    \r\n  // If an outgoing link points to a group NOT in our fetched list, fetch it now\r\n  const existingIds = new Set(formattedGroups.map(g => g.id));\r\n  const missingIds = outgoingLinkIds.filter(id => !existingIds.has(id));\r\n\r\n  if (missingIds.length > 0) {\r\n    const { data: externalGroups } = await supabase\r\n      .from('approval_groups')\r\n      .select('id, group_name, next_approver_group_id, company_id, is_final_authority')\r\n      .in('id', missingIds);\r\n\r\n    if (externalGroups) {\r\n        // Add external nodes (like Commandant Staff) to the list so we can render them\r\n        formattedGroups.push(...(externalGroups as any[]));\r\n    }\r\n  }\r\n\r\n  return formattedGroups;\r\n}\r\n\r\n/**\r\n * INSERT LOGIC:\r\n * User selects \"Who does this new group approve?\" (Child Group).\r\n * We insert the New Group *between* the Child and the Child's current approver.\r\n */\r\nexport async function createGroupAction(\r\n  companyId: string, \r\n  groupName: string, \r\n  childGroupIdToApprove: string // The group that will report TO this new group\r\n) {\r\n  const supabase = createClient()\r\n\r\n  // 1. Get the Child Group to see who it currently points to\r\n  const { data: childGroup, error: fetchError } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', childGroupIdToApprove)\r\n    .single();\r\n\r\n  if (fetchError || !childGroup) return { error: \"Could not find the group you selected to approve.\" };\r\n\r\n  const oldParentId = childGroup.next_approver_group_id;\r\n\r\n  // 2. Create the New Group\r\n  // Point it to the Child's OLD parent (or null if Child was top)\r\n  const { data: newGroup, error: createError } = await supabase\r\n    .from('approval_groups')\r\n    .insert({\r\n      group_name: groupName,\r\n      company_id: companyId,\r\n      next_approver_group_id: oldParentId,\r\n      is_final_authority: false\r\n    })\r\n    .select('id')\r\n    .single();\r\n\r\n  if (createError) return { error: createError.message };\r\n\r\n  // 3. Update the Child Group\r\n  // Point it to the NEW group\r\n  const { error: updateError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ next_approver_group_id: newGroup.id })\r\n    .eq('id', childGroupIdToApprove);\r\n\r\n  if (updateError) return { error: \"Failed to re-link the chain.\" };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n/**\r\n * DELETE LOGIC:\r\n * 1. Find who the target group points to (Parent).\r\n * 2. Find everyone pointing TO the target group (Children).\r\n * 3. Point all Children to the Parent.\r\n * 4. Delete the target.\r\n */\r\nexport async function deleteGroupAction(groupId: string) {\r\n  const supabase = createClient()\r\n\r\n  // 1. Get Target info\r\n  const { data: targetGroup } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', groupId)\r\n    .single();\r\n  \r\n  if (!targetGroup) return { error: \"Group not found\" };\r\n\r\n  const parentId = targetGroup.next_approver_group_id;\r\n\r\n  // 2. Re-link children (Update Step)\r\n  const { error: relinkError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ next_approver_group_id: parentId })\r\n    .eq('next_approver_group_id', groupId); // Find anyone pointing to ME\r\n\r\n  if (relinkError) return { error: \"Failed to re-link children groups.\" };\r\n\r\n  // 3. Delete the group\r\n  const { error: deleteError } = await supabase\r\n    .from('approval_groups')\r\n    .delete()\r\n    .eq('id', groupId);\r\n\r\n  if (deleteError) return { error: deleteError.message };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n// ... existing imports and code\r\n\r\n// --- ROLE MANAGEMENT ---\r\n\r\nexport async function getGroupRoles(groupId: string) {\r\n  const supabase = createClient()\r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('approval_group_id', groupId)\r\n    .order('role_name')\r\n  \r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\nexport async function deleteRoleAction(roleId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // Security check: ensure no users are assigned? \r\n  // For now, we'll just delete. Supabase might throw FK error if used.\r\n  const { error } = await supabase.from('roles').delete().eq('id', roleId)\r\n  \r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}\r\n\r\nexport async function createRoleAction(\r\n  companyId: string,\r\n  groupId: string,\r\n  roleName: string,\r\n  defaultLevel: number\r\n) {\r\n  const supabase = createClient()\r\n\r\n  const { error } = await supabase.from('roles').insert({\r\n    company_id: companyId,\r\n    approval_group_id: groupId,\r\n    role_name: roleName,\r\n    default_role_level: defaultLevel,\r\n    can_manage_own_company_roster: defaultLevel >= 40, // Basic logic\r\n    can_manage_all_rosters: defaultLevel >= 50\r\n  })\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}"],"names":[],"mappings":";;;;;;;IAkIsB,oBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA","debugId":null}},
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/components/GroupNode.tsx"],"sourcesContent":["// app/manage/roles/components/GroupNode.tsx\r\nimport { ApprovalGroupNode } from '../actions'\r\nimport React from 'react'\r\n\r\ninterface GroupNodeProps {\r\n  node: ApprovalGroupNode\r\n  onDelete: (e: React.MouseEvent) => void\r\n  onAddParent: (e: React.MouseEvent) => void\r\n}\r\n\r\nexport default function GroupNode({ node, onDelete, onAddParent }: GroupNodeProps) {\r\n  \r\n  const isFinal = node.is_final_authority\r\n  \r\n  return (\r\n    <div className=\"relative group flex items-center\">\r\n      \r\n      {/* The Box */}\r\n      <div className={`\r\n        relative w-64 p-4 rounded-lg border-2 shadow-md transition-all hover:shadow-lg bg-white dark:bg-gray-800\r\n        ${isFinal ? 'border-yellow-500 dark:border-yellow-500 ring-2 ring-yellow-100 dark:ring-yellow-900/30' : 'border-gray-200 dark:border-gray-700'}\r\n      `}>\r\n        \r\n        {/* Header */}\r\n        <div className=\"flex justify-between items-start mb-2\">\r\n          <h3 className=\"font-bold text-gray-900 dark:text-white text-sm leading-tight\">\r\n            {node.group_name}\r\n          </h3>\r\n          {/* Delete Button (Only show if not final/external) */}\r\n          {!isFinal && (\r\n             <button \r\n               onClick={onDelete}\r\n               className=\"text-gray-400 hover:text-red-600 transition-colors opacity-0 group-hover:opacity-100\"\r\n               title=\"Delete Group\"\r\n             >\r\n               <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" /></svg>\r\n             </button>\r\n          )}\r\n        </div>\r\n\r\n        {/* Stats */}\r\n        <div className=\"text-xs text-gray-500 dark:text-gray-400 flex gap-2\">\r\n          <span>Roles: {node.role_count || 0}</span>\r\n          {isFinal && <span className=\"text-yellow-600 font-semibold ml-auto\">Final Authority</span>}\r\n        </div>\r\n\r\n        {/* Insert Button (The \"Link\" connector) */}\r\n        {/* Only show insert button if it's NOT the final authority (can't insert after final) */}\r\n        {!isFinal && (\r\n          <div className=\"absolute -right-5 top-1/2 -translate-y-1/2 z-10\">\r\n             <button \r\n               onClick={onAddParent}\r\n               className=\"flex items-center justify-center w-8 h-8 bg-indigo-600 text-white rounded-full shadow hover:bg-indigo-700 hover:scale-110 transition-all border-2 border-white dark:border-gray-900\"\r\n               title=\"Insert Approval Level\"\r\n             >\r\n               <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 4v16m8-8H4\" /></svg>\r\n             </button>\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* Connection Line (Visual only) */}\r\n      {!isFinal && (\r\n        <div className=\"w-6 h-0.5 bg-gray-300 dark:bg-gray-600 mx-2\"></div>\r\n      )}\r\n    </div>\r\n  )\r\n}"],"names":[],"mappings":"AAAA,4CAA4C;;;;;;;AAU7B,SAAS,UAAU,EAAE,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAkB;IAE/E,MAAM,UAAU,KAAK,kBAAkB;IAEvC,qBACE,8OAAC;QAAI,WAAU;;0BAGb,8OAAC;gBAAI,WAAW,CAAC;;QAEf,EAAE,UAAU,4FAA4F,uCAAuC;MACjJ,CAAC;;kCAGC,8OAAC;wBAAI,WAAU;;0CACb,8OAAC;gCAAG,WAAU;0CACX,KAAK,UAAU;;;;;;4BAGjB,CAAC,yBACC,8OAAC;gCACC,SAAS;gCACT,WAAU;gCACV,OAAM;0CAEN,cAAA,8OAAC;oCAAI,WAAU;oCAAU,MAAK;oCAAO,QAAO;oCAAe,SAAQ;8CAAY,cAAA,8OAAC;wCAAK,eAAc;wCAAQ,gBAAe;wCAAQ,aAAa;wCAAG,GAAE;;;;;;;;;;;;;;;;;;;;;;kCAM3J,8OAAC;wBAAI,WAAU;;0CACb,8OAAC;;oCAAK;oCAAQ,KAAK,UAAU,IAAI;;;;;;;4BAChC,yBAAW,8OAAC;gCAAK,WAAU;0CAAwC;;;;;;;;;;;;oBAKrE,CAAC,yBACA,8OAAC;wBAAI,WAAU;kCACZ,cAAA,8OAAC;4BACC,SAAS;4BACT,WAAU;4BACV,OAAM;sCAEN,cAAA,8OAAC;gCAAI,WAAU;gCAAU,MAAK;gCAAO,QAAO;gCAAe,SAAQ;0CAAY,cAAA,8OAAC;oCAAK,eAAc;oCAAQ,gBAAe;oCAAQ,aAAa;oCAAG,GAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;YAO5J,CAAC,yBACA,8OAAC;gBAAI,WAAU;;;;;;;;;;;;AAIvB","debugId":null}},
    {"offset": {"line": 179, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { createClient } from '@/utils/supabase/server'\r\nimport { revalidatePath } from 'next/cache'\r\n\r\nexport type ApprovalGroupNode = {\r\n  id: string;\r\n  group_name: string;\r\n  next_approver_group_id: string | null;\r\n  company_id: string;\r\n  is_final_authority: boolean;\r\n  role_count?: number; // We'll fetch how many roles are in this group\r\n}\r\n\r\n/**\r\n * Fetches the flat list of groups for a company.\r\n * The visualizer will reconstruct the tree from this flat list.\r\n */\r\nexport async function getCompanyChain(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // 1. Fetch groups for the company\r\n  const { data: companyGroups, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, \r\n      group_name, \r\n      next_approver_group_id, \r\n      company_id, \r\n      is_final_authority,\r\n      roles:roles(count)\r\n    `)\r\n    .eq('company_id', companyId)\r\n\r\n  if (error) {\r\n    console.error('Error fetching chain:', error)\r\n    return []\r\n  }\r\n\r\n  // 2. Flatten the count\r\n  // (Supabase returns { count: 5 } array, we just want the number)\r\n  const formattedGroups = companyGroups.map(g => ({\r\n    ...g,\r\n    role_count: g.roles ? (g.roles as any)[0]?.count || 0 : 0\r\n  })) as ApprovalGroupNode[]\r\n\r\n  // 3. Fetch the \"Final Authority\" groups (Commandant/Battalion) \r\n  // We need these to show the end of the chain, even if they belong to a different company\r\n  // We find them by looking at the 'next_approver_group_id' of the top-level company groups\r\n  const outgoingLinkIds = formattedGroups\r\n    .map(g => g.next_approver_group_id)\r\n    .filter(id => id !== null) as string[];\r\n    \r\n  // If an outgoing link points to a group NOT in our fetched list, fetch it now\r\n  const existingIds = new Set(formattedGroups.map(g => g.id));\r\n  const missingIds = outgoingLinkIds.filter(id => !existingIds.has(id));\r\n\r\n  if (missingIds.length > 0) {\r\n    const { data: externalGroups } = await supabase\r\n      .from('approval_groups')\r\n      .select('id, group_name, next_approver_group_id, company_id, is_final_authority')\r\n      .in('id', missingIds);\r\n\r\n    if (externalGroups) {\r\n        // Add external nodes (like Commandant Staff) to the list so we can render them\r\n        formattedGroups.push(...(externalGroups as any[]));\r\n    }\r\n  }\r\n\r\n  return formattedGroups;\r\n}\r\n\r\n/**\r\n * INSERT LOGIC:\r\n * User selects \"Who does this new group approve?\" (Child Group).\r\n * We insert the New Group *between* the Child and the Child's current approver.\r\n */\r\nexport async function createGroupAction(\r\n  companyId: string, \r\n  groupName: string, \r\n  childGroupIdToApprove: string // The group that will report TO this new group\r\n) {\r\n  const supabase = createClient()\r\n\r\n  // 1. Get the Child Group to see who it currently points to\r\n  const { data: childGroup, error: fetchError } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', childGroupIdToApprove)\r\n    .single();\r\n\r\n  if (fetchError || !childGroup) return { error: \"Could not find the group you selected to approve.\" };\r\n\r\n  const oldParentId = childGroup.next_approver_group_id;\r\n\r\n  // 2. Create the New Group\r\n  // Point it to the Child's OLD parent (or null if Child was top)\r\n  const { data: newGroup, error: createError } = await supabase\r\n    .from('approval_groups')\r\n    .insert({\r\n      group_name: groupName,\r\n      company_id: companyId,\r\n      next_approver_group_id: oldParentId,\r\n      is_final_authority: false\r\n    })\r\n    .select('id')\r\n    .single();\r\n\r\n  if (createError) return { error: createError.message };\r\n\r\n  // 3. Update the Child Group\r\n  // Point it to the NEW group\r\n  const { error: updateError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ next_approver_group_id: newGroup.id })\r\n    .eq('id', childGroupIdToApprove);\r\n\r\n  if (updateError) return { error: \"Failed to re-link the chain.\" };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n/**\r\n * DELETE LOGIC:\r\n * 1. Find who the target group points to (Parent).\r\n * 2. Find everyone pointing TO the target group (Children).\r\n * 3. Point all Children to the Parent.\r\n * 4. Delete the target.\r\n */\r\nexport async function deleteGroupAction(groupId: string) {\r\n  const supabase = createClient()\r\n\r\n  // 1. Get Target info\r\n  const { data: targetGroup } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', groupId)\r\n    .single();\r\n  \r\n  if (!targetGroup) return { error: \"Group not found\" };\r\n\r\n  const parentId = targetGroup.next_approver_group_id;\r\n\r\n  // 2. Re-link children (Update Step)\r\n  const { error: relinkError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ next_approver_group_id: parentId })\r\n    .eq('next_approver_group_id', groupId); // Find anyone pointing to ME\r\n\r\n  if (relinkError) return { error: \"Failed to re-link children groups.\" };\r\n\r\n  // 3. Delete the group\r\n  const { error: deleteError } = await supabase\r\n    .from('approval_groups')\r\n    .delete()\r\n    .eq('id', groupId);\r\n\r\n  if (deleteError) return { error: deleteError.message };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n// ... existing imports and code\r\n\r\n// --- ROLE MANAGEMENT ---\r\n\r\nexport async function getGroupRoles(groupId: string) {\r\n  const supabase = createClient()\r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('approval_group_id', groupId)\r\n    .order('role_name')\r\n  \r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\nexport async function deleteRoleAction(roleId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // Security check: ensure no users are assigned? \r\n  // For now, we'll just delete. Supabase might throw FK error if used.\r\n  const { error } = await supabase.from('roles').delete().eq('id', roleId)\r\n  \r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}\r\n\r\nexport async function createRoleAction(\r\n  companyId: string,\r\n  groupId: string,\r\n  roleName: string,\r\n  defaultLevel: number\r\n) {\r\n  const supabase = createClient()\r\n\r\n  const { error } = await supabase.from('roles').insert({\r\n    company_id: companyId,\r\n    approval_group_id: groupId,\r\n    role_name: roleName,\r\n    default_role_level: defaultLevel,\r\n    can_manage_own_company_roster: defaultLevel >= 40, // Basic logic\r\n    can_manage_all_rosters: defaultLevel >= 50\r\n  })\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}"],"names":[],"mappings":";;;;;;;IA6EsB,oBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA","debugId":null}},
    {"offset": {"line": 191, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/components/AddGroupModal.tsx"],"sourcesContent":["// app/manage/roles/components/AddGroupModal.tsx\r\n'use client'\r\nimport { useState } from 'react'\r\nimport { createGroupAction } from '../actions'\r\n\r\ninterface AddGroupModalProps {\r\n  isOpen: boolean\r\n  onClose: () => void\r\n  companyId: string\r\n  childGroupId: string // The group that will report TO this new group\r\n  onSuccess: () => void\r\n}\r\n\r\nexport default function AddGroupModal({ isOpen, onClose, companyId, childGroupId, onSuccess }: AddGroupModalProps) {\r\n  const [name, setName] = useState('')\r\n  const [loading, setLoading] = useState(false)\r\n\r\n  const handleSubmit = async (e: React.FormEvent) => {\r\n    e.preventDefault()\r\n    if (!name.trim()) return\r\n    \r\n    setLoading(true)\r\n    const result = await createGroupAction(companyId, name, childGroupId)\r\n    setLoading(false)\r\n\r\n    if (result?.error) {\r\n      alert(result.error)\r\n    } else {\r\n      onSuccess()\r\n    }\r\n  }\r\n\r\n  if (!isOpen) return null\r\n\r\n  return (\r\n    <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm\">\r\n      <div className=\"bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl w-96 border dark:border-gray-700\">\r\n        <h2 className=\"text-lg font-bold mb-4 text-gray-900 dark:text-white\">Insert Approval Step</h2>\r\n        <p className=\"text-sm text-gray-500 mb-4\">\r\n          This new group will approve reports coming from the selected group, and then forward them up the existing chain.\r\n        </p>\r\n        \r\n        <form onSubmit={handleSubmit}>\r\n          <div className=\"mb-4\">\r\n            <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">Group Name</label>\r\n            <input \r\n              type=\"text\" \r\n              value={name} \r\n              onChange={e => setName(e.target.value)}\r\n              placeholder=\"e.g. Platoon Sergeant\"\r\n              className=\"w-full rounded-md border-gray-300 dark:border-gray-600 dark:bg-gray-900 dark:text-white p-2\"\r\n              autoFocus\r\n            />\r\n          </div>\r\n\r\n          <div className=\"flex justify-end gap-2\">\r\n            <button type=\"button\" onClick={onClose} className=\"px-3 py-1.5 text-sm text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded\">Cancel</button>\r\n            <button \r\n              type=\"submit\" \r\n              disabled={loading || !name.trim()}\r\n              className=\"px-3 py-1.5 text-sm bg-indigo-600 text-white rounded hover:bg-indigo-700 disabled:opacity-50\"\r\n            >\r\n              {loading ? 'Saving...' : 'Create & Insert'}\r\n            </button>\r\n          </div>\r\n        </form>\r\n      </div>\r\n    </div>\r\n  )\r\n}"],"names":[],"mappings":"AAAA,gDAAgD;;;;;;AAEhD;AACA;AAFA;;;;AAYe,SAAS,cAAc,EAAE,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,YAAY,EAAE,SAAS,EAAsB;IAC/G,MAAM,CAAC,MAAM,QAAQ,GAAG,IAAA,iNAAQ,EAAC;IACjC,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,iNAAQ,EAAC;IAEvC,MAAM,eAAe,OAAO;QAC1B,EAAE,cAAc;QAChB,IAAI,CAAC,KAAK,IAAI,IAAI;QAElB,WAAW;QACX,MAAM,SAAS,MAAM,IAAA,mLAAiB,EAAC,WAAW,MAAM;QACxD,WAAW;QAEX,IAAI,QAAQ,OAAO;YACjB,MAAM,OAAO,KAAK;QACpB,OAAO;YACL;QACF;IACF;IAEA,IAAI,CAAC,QAAQ,OAAO;IAEpB,qBACE,8OAAC;QAAI,WAAU;kBACb,cAAA,8OAAC;YAAI,WAAU;;8BACb,8OAAC;oBAAG,WAAU;8BAAuD;;;;;;8BACrE,8OAAC;oBAAE,WAAU;8BAA6B;;;;;;8BAI1C,8OAAC;oBAAK,UAAU;;sCACd,8OAAC;4BAAI,WAAU;;8CACb,8OAAC;oCAAM,WAAU;8CAAkE;;;;;;8CACnF,8OAAC;oCACC,MAAK;oCACL,OAAO;oCACP,UAAU,CAAA,IAAK,QAAQ,EAAE,MAAM,CAAC,KAAK;oCACrC,aAAY;oCACZ,WAAU;oCACV,SAAS;;;;;;;;;;;;sCAIb,8OAAC;4BAAI,WAAU;;8CACb,8OAAC;oCAAO,MAAK;oCAAS,SAAS;oCAAS,WAAU;8CAAwG;;;;;;8CAC1J,8OAAC;oCACC,MAAK;oCACL,UAAU,WAAW,CAAC,KAAK,IAAI;oCAC/B,WAAU;8CAET,UAAU,cAAc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOvC","debugId":null}},
    {"offset": {"line": 323, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { createClient } from '@/utils/supabase/server'\r\nimport { revalidatePath } from 'next/cache'\r\n\r\nexport type ApprovalGroupNode = {\r\n  id: string;\r\n  group_name: string;\r\n  next_approver_group_id: string | null;\r\n  company_id: string;\r\n  is_final_authority: boolean;\r\n  role_count?: number; // We'll fetch how many roles are in this group\r\n}\r\n\r\n/**\r\n * Fetches the flat list of groups for a company.\r\n * The visualizer will reconstruct the tree from this flat list.\r\n */\r\nexport async function getCompanyChain(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // 1. Fetch groups for the company\r\n  const { data: companyGroups, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, \r\n      group_name, \r\n      next_approver_group_id, \r\n      company_id, \r\n      is_final_authority,\r\n      roles:roles(count)\r\n    `)\r\n    .eq('company_id', companyId)\r\n\r\n  if (error) {\r\n    console.error('Error fetching chain:', error)\r\n    return []\r\n  }\r\n\r\n  // 2. Flatten the count\r\n  // (Supabase returns { count: 5 } array, we just want the number)\r\n  const formattedGroups = companyGroups.map(g => ({\r\n    ...g,\r\n    role_count: g.roles ? (g.roles as any)[0]?.count || 0 : 0\r\n  })) as ApprovalGroupNode[]\r\n\r\n  // 3. Fetch the \"Final Authority\" groups (Commandant/Battalion) \r\n  // We need these to show the end of the chain, even if they belong to a different company\r\n  // We find them by looking at the 'next_approver_group_id' of the top-level company groups\r\n  const outgoingLinkIds = formattedGroups\r\n    .map(g => g.next_approver_group_id)\r\n    .filter(id => id !== null) as string[];\r\n    \r\n  // If an outgoing link points to a group NOT in our fetched list, fetch it now\r\n  const existingIds = new Set(formattedGroups.map(g => g.id));\r\n  const missingIds = outgoingLinkIds.filter(id => !existingIds.has(id));\r\n\r\n  if (missingIds.length > 0) {\r\n    const { data: externalGroups } = await supabase\r\n      .from('approval_groups')\r\n      .select('id, group_name, next_approver_group_id, company_id, is_final_authority')\r\n      .in('id', missingIds);\r\n\r\n    if (externalGroups) {\r\n        // Add external nodes (like Commandant Staff) to the list so we can render them\r\n        formattedGroups.push(...(externalGroups as any[]));\r\n    }\r\n  }\r\n\r\n  return formattedGroups;\r\n}\r\n\r\n/**\r\n * INSERT LOGIC:\r\n * User selects \"Who does this new group approve?\" (Child Group).\r\n * We insert the New Group *between* the Child and the Child's current approver.\r\n */\r\nexport async function createGroupAction(\r\n  companyId: string, \r\n  groupName: string, \r\n  childGroupIdToApprove: string // The group that will report TO this new group\r\n) {\r\n  const supabase = createClient()\r\n\r\n  // 1. Get the Child Group to see who it currently points to\r\n  const { data: childGroup, error: fetchError } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', childGroupIdToApprove)\r\n    .single();\r\n\r\n  if (fetchError || !childGroup) return { error: \"Could not find the group you selected to approve.\" };\r\n\r\n  const oldParentId = childGroup.next_approver_group_id;\r\n\r\n  // 2. Create the New Group\r\n  // Point it to the Child's OLD parent (or null if Child was top)\r\n  const { data: newGroup, error: createError } = await supabase\r\n    .from('approval_groups')\r\n    .insert({\r\n      group_name: groupName,\r\n      company_id: companyId,\r\n      next_approver_group_id: oldParentId,\r\n      is_final_authority: false\r\n    })\r\n    .select('id')\r\n    .single();\r\n\r\n  if (createError) return { error: createError.message };\r\n\r\n  // 3. Update the Child Group\r\n  // Point it to the NEW group\r\n  const { error: updateError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ next_approver_group_id: newGroup.id })\r\n    .eq('id', childGroupIdToApprove);\r\n\r\n  if (updateError) return { error: \"Failed to re-link the chain.\" };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n/**\r\n * DELETE LOGIC:\r\n * 1. Find who the target group points to (Parent).\r\n * 2. Find everyone pointing TO the target group (Children).\r\n * 3. Point all Children to the Parent.\r\n * 4. Delete the target.\r\n */\r\nexport async function deleteGroupAction(groupId: string) {\r\n  const supabase = createClient()\r\n\r\n  // 1. Get Target info\r\n  const { data: targetGroup } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', groupId)\r\n    .single();\r\n  \r\n  if (!targetGroup) return { error: \"Group not found\" };\r\n\r\n  const parentId = targetGroup.next_approver_group_id;\r\n\r\n  // 2. Re-link children (Update Step)\r\n  const { error: relinkError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ next_approver_group_id: parentId })\r\n    .eq('next_approver_group_id', groupId); // Find anyone pointing to ME\r\n\r\n  if (relinkError) return { error: \"Failed to re-link children groups.\" };\r\n\r\n  // 3. Delete the group\r\n  const { error: deleteError } = await supabase\r\n    .from('approval_groups')\r\n    .delete()\r\n    .eq('id', groupId);\r\n\r\n  if (deleteError) return { error: deleteError.message };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n// ... existing imports and code\r\n\r\n// --- ROLE MANAGEMENT ---\r\n\r\nexport async function getGroupRoles(groupId: string) {\r\n  const supabase = createClient()\r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('approval_group_id', groupId)\r\n    .order('role_name')\r\n  \r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\nexport async function deleteRoleAction(roleId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // Security check: ensure no users are assigned? \r\n  // For now, we'll just delete. Supabase might throw FK error if used.\r\n  const { error } = await supabase.from('roles').delete().eq('id', roleId)\r\n  \r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}\r\n\r\nexport async function createRoleAction(\r\n  companyId: string,\r\n  groupId: string,\r\n  roleName: string,\r\n  defaultLevel: number\r\n) {\r\n  const supabase = createClient()\r\n\r\n  const { error } = await supabase.from('roles').insert({\r\n    company_id: companyId,\r\n    approval_group_id: groupId,\r\n    role_name: roleName,\r\n    default_role_level: defaultLevel,\r\n    can_manage_own_company_roster: defaultLevel >= 40, // Basic logic\r\n    can_manage_all_rosters: defaultLevel >= 50\r\n  })\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}"],"names":[],"mappings":";;;;;;;IAwKsB,gBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA","debugId":null}},
    {"offset": {"line": 335, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { createClient } from '@/utils/supabase/server'\r\nimport { revalidatePath } from 'next/cache'\r\n\r\nexport type ApprovalGroupNode = {\r\n  id: string;\r\n  group_name: string;\r\n  next_approver_group_id: string | null;\r\n  company_id: string;\r\n  is_final_authority: boolean;\r\n  role_count?: number; // We'll fetch how many roles are in this group\r\n}\r\n\r\n/**\r\n * Fetches the flat list of groups for a company.\r\n * The visualizer will reconstruct the tree from this flat list.\r\n */\r\nexport async function getCompanyChain(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // 1. Fetch groups for the company\r\n  const { data: companyGroups, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, \r\n      group_name, \r\n      next_approver_group_id, \r\n      company_id, \r\n      is_final_authority,\r\n      roles:roles(count)\r\n    `)\r\n    .eq('company_id', companyId)\r\n\r\n  if (error) {\r\n    console.error('Error fetching chain:', error)\r\n    return []\r\n  }\r\n\r\n  // 2. Flatten the count\r\n  // (Supabase returns { count: 5 } array, we just want the number)\r\n  const formattedGroups = companyGroups.map(g => ({\r\n    ...g,\r\n    role_count: g.roles ? (g.roles as any)[0]?.count || 0 : 0\r\n  })) as ApprovalGroupNode[]\r\n\r\n  // 3. Fetch the \"Final Authority\" groups (Commandant/Battalion) \r\n  // We need these to show the end of the chain, even if they belong to a different company\r\n  // We find them by looking at the 'next_approver_group_id' of the top-level company groups\r\n  const outgoingLinkIds = formattedGroups\r\n    .map(g => g.next_approver_group_id)\r\n    .filter(id => id !== null) as string[];\r\n    \r\n  // If an outgoing link points to a group NOT in our fetched list, fetch it now\r\n  const existingIds = new Set(formattedGroups.map(g => g.id));\r\n  const missingIds = outgoingLinkIds.filter(id => !existingIds.has(id));\r\n\r\n  if (missingIds.length > 0) {\r\n    const { data: externalGroups } = await supabase\r\n      .from('approval_groups')\r\n      .select('id, group_name, next_approver_group_id, company_id, is_final_authority')\r\n      .in('id', missingIds);\r\n\r\n    if (externalGroups) {\r\n        // Add external nodes (like Commandant Staff) to the list so we can render them\r\n        formattedGroups.push(...(externalGroups as any[]));\r\n    }\r\n  }\r\n\r\n  return formattedGroups;\r\n}\r\n\r\n/**\r\n * INSERT LOGIC:\r\n * User selects \"Who does this new group approve?\" (Child Group).\r\n * We insert the New Group *between* the Child and the Child's current approver.\r\n */\r\nexport async function createGroupAction(\r\n  companyId: string, \r\n  groupName: string, \r\n  childGroupIdToApprove: string // The group that will report TO this new group\r\n) {\r\n  const supabase = createClient()\r\n\r\n  // 1. Get the Child Group to see who it currently points to\r\n  const { data: childGroup, error: fetchError } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', childGroupIdToApprove)\r\n    .single();\r\n\r\n  if (fetchError || !childGroup) return { error: \"Could not find the group you selected to approve.\" };\r\n\r\n  const oldParentId = childGroup.next_approver_group_id;\r\n\r\n  // 2. Create the New Group\r\n  // Point it to the Child's OLD parent (or null if Child was top)\r\n  const { data: newGroup, error: createError } = await supabase\r\n    .from('approval_groups')\r\n    .insert({\r\n      group_name: groupName,\r\n      company_id: companyId,\r\n      next_approver_group_id: oldParentId,\r\n      is_final_authority: false\r\n    })\r\n    .select('id')\r\n    .single();\r\n\r\n  if (createError) return { error: createError.message };\r\n\r\n  // 3. Update the Child Group\r\n  // Point it to the NEW group\r\n  const { error: updateError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ next_approver_group_id: newGroup.id })\r\n    .eq('id', childGroupIdToApprove);\r\n\r\n  if (updateError) return { error: \"Failed to re-link the chain.\" };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n/**\r\n * DELETE LOGIC:\r\n * 1. Find who the target group points to (Parent).\r\n * 2. Find everyone pointing TO the target group (Children).\r\n * 3. Point all Children to the Parent.\r\n * 4. Delete the target.\r\n */\r\nexport async function deleteGroupAction(groupId: string) {\r\n  const supabase = createClient()\r\n\r\n  // 1. Get Target info\r\n  const { data: targetGroup } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', groupId)\r\n    .single();\r\n  \r\n  if (!targetGroup) return { error: \"Group not found\" };\r\n\r\n  const parentId = targetGroup.next_approver_group_id;\r\n\r\n  // 2. Re-link children (Update Step)\r\n  const { error: relinkError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ next_approver_group_id: parentId })\r\n    .eq('next_approver_group_id', groupId); // Find anyone pointing to ME\r\n\r\n  if (relinkError) return { error: \"Failed to re-link children groups.\" };\r\n\r\n  // 3. Delete the group\r\n  const { error: deleteError } = await supabase\r\n    .from('approval_groups')\r\n    .delete()\r\n    .eq('id', groupId);\r\n\r\n  if (deleteError) return { error: deleteError.message };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n// ... existing imports and code\r\n\r\n// --- ROLE MANAGEMENT ---\r\n\r\nexport async function getGroupRoles(groupId: string) {\r\n  const supabase = createClient()\r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('approval_group_id', groupId)\r\n    .order('role_name')\r\n  \r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\nexport async function deleteRoleAction(roleId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // Security check: ensure no users are assigned? \r\n  // For now, we'll just delete. Supabase might throw FK error if used.\r\n  const { error } = await supabase.from('roles').delete().eq('id', roleId)\r\n  \r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}\r\n\r\nexport async function createRoleAction(\r\n  companyId: string,\r\n  groupId: string,\r\n  roleName: string,\r\n  defaultLevel: number\r\n) {\r\n  const supabase = createClient()\r\n\r\n  const { error } = await supabase.from('roles').insert({\r\n    company_id: companyId,\r\n    approval_group_id: groupId,\r\n    role_name: roleName,\r\n    default_role_level: defaultLevel,\r\n    can_manage_own_company_roster: defaultLevel >= 40, // Basic logic\r\n    can_manage_all_rosters: defaultLevel >= 50\r\n  })\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}"],"names":[],"mappings":";;;;;;;IAmLsB,mBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA","debugId":null}},
    {"offset": {"line": 347, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { createClient } from '@/utils/supabase/server'\r\nimport { revalidatePath } from 'next/cache'\r\n\r\nexport type ApprovalGroupNode = {\r\n  id: string;\r\n  group_name: string;\r\n  next_approver_group_id: string | null;\r\n  company_id: string;\r\n  is_final_authority: boolean;\r\n  role_count?: number; // We'll fetch how many roles are in this group\r\n}\r\n\r\n/**\r\n * Fetches the flat list of groups for a company.\r\n * The visualizer will reconstruct the tree from this flat list.\r\n */\r\nexport async function getCompanyChain(companyId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // 1. Fetch groups for the company\r\n  const { data: companyGroups, error } = await supabase\r\n    .from('approval_groups')\r\n    .select(`\r\n      id, \r\n      group_name, \r\n      next_approver_group_id, \r\n      company_id, \r\n      is_final_authority,\r\n      roles:roles(count)\r\n    `)\r\n    .eq('company_id', companyId)\r\n\r\n  if (error) {\r\n    console.error('Error fetching chain:', error)\r\n    return []\r\n  }\r\n\r\n  // 2. Flatten the count\r\n  // (Supabase returns { count: 5 } array, we just want the number)\r\n  const formattedGroups = companyGroups.map(g => ({\r\n    ...g,\r\n    role_count: g.roles ? (g.roles as any)[0]?.count || 0 : 0\r\n  })) as ApprovalGroupNode[]\r\n\r\n  // 3. Fetch the \"Final Authority\" groups (Commandant/Battalion) \r\n  // We need these to show the end of the chain, even if they belong to a different company\r\n  // We find them by looking at the 'next_approver_group_id' of the top-level company groups\r\n  const outgoingLinkIds = formattedGroups\r\n    .map(g => g.next_approver_group_id)\r\n    .filter(id => id !== null) as string[];\r\n    \r\n  // If an outgoing link points to a group NOT in our fetched list, fetch it now\r\n  const existingIds = new Set(formattedGroups.map(g => g.id));\r\n  const missingIds = outgoingLinkIds.filter(id => !existingIds.has(id));\r\n\r\n  if (missingIds.length > 0) {\r\n    const { data: externalGroups } = await supabase\r\n      .from('approval_groups')\r\n      .select('id, group_name, next_approver_group_id, company_id, is_final_authority')\r\n      .in('id', missingIds);\r\n\r\n    if (externalGroups) {\r\n        // Add external nodes (like Commandant Staff) to the list so we can render them\r\n        formattedGroups.push(...(externalGroups as any[]));\r\n    }\r\n  }\r\n\r\n  return formattedGroups;\r\n}\r\n\r\n/**\r\n * INSERT LOGIC:\r\n * User selects \"Who does this new group approve?\" (Child Group).\r\n * We insert the New Group *between* the Child and the Child's current approver.\r\n */\r\nexport async function createGroupAction(\r\n  companyId: string, \r\n  groupName: string, \r\n  childGroupIdToApprove: string // The group that will report TO this new group\r\n) {\r\n  const supabase = createClient()\r\n\r\n  // 1. Get the Child Group to see who it currently points to\r\n  const { data: childGroup, error: fetchError } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', childGroupIdToApprove)\r\n    .single();\r\n\r\n  if (fetchError || !childGroup) return { error: \"Could not find the group you selected to approve.\" };\r\n\r\n  const oldParentId = childGroup.next_approver_group_id;\r\n\r\n  // 2. Create the New Group\r\n  // Point it to the Child's OLD parent (or null if Child was top)\r\n  const { data: newGroup, error: createError } = await supabase\r\n    .from('approval_groups')\r\n    .insert({\r\n      group_name: groupName,\r\n      company_id: companyId,\r\n      next_approver_group_id: oldParentId,\r\n      is_final_authority: false\r\n    })\r\n    .select('id')\r\n    .single();\r\n\r\n  if (createError) return { error: createError.message };\r\n\r\n  // 3. Update the Child Group\r\n  // Point it to the NEW group\r\n  const { error: updateError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ next_approver_group_id: newGroup.id })\r\n    .eq('id', childGroupIdToApprove);\r\n\r\n  if (updateError) return { error: \"Failed to re-link the chain.\" };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n/**\r\n * DELETE LOGIC:\r\n * 1. Find who the target group points to (Parent).\r\n * 2. Find everyone pointing TO the target group (Children).\r\n * 3. Point all Children to the Parent.\r\n * 4. Delete the target.\r\n */\r\nexport async function deleteGroupAction(groupId: string) {\r\n  const supabase = createClient()\r\n\r\n  // 1. Get Target info\r\n  const { data: targetGroup } = await supabase\r\n    .from('approval_groups')\r\n    .select('next_approver_group_id')\r\n    .eq('id', groupId)\r\n    .single();\r\n  \r\n  if (!targetGroup) return { error: \"Group not found\" };\r\n\r\n  const parentId = targetGroup.next_approver_group_id;\r\n\r\n  // 2. Re-link children (Update Step)\r\n  const { error: relinkError } = await supabase\r\n    .from('approval_groups')\r\n    .update({ next_approver_group_id: parentId })\r\n    .eq('next_approver_group_id', groupId); // Find anyone pointing to ME\r\n\r\n  if (relinkError) return { error: \"Failed to re-link children groups.\" };\r\n\r\n  // 3. Delete the group\r\n  const { error: deleteError } = await supabase\r\n    .from('approval_groups')\r\n    .delete()\r\n    .eq('id', groupId);\r\n\r\n  if (deleteError) return { error: deleteError.message };\r\n\r\n  revalidatePath('/manage/roles');\r\n  return { success: true };\r\n}\r\n\r\n// ... existing imports and code\r\n\r\n// --- ROLE MANAGEMENT ---\r\n\r\nexport async function getGroupRoles(groupId: string) {\r\n  const supabase = createClient()\r\n  const { data, error } = await supabase\r\n    .from('roles')\r\n    .select('id, role_name, default_role_level')\r\n    .eq('approval_group_id', groupId)\r\n    .order('role_name')\r\n  \r\n  return { roles: data || [], error: error?.message }\r\n}\r\n\r\nexport async function deleteRoleAction(roleId: string) {\r\n  const supabase = createClient()\r\n  \r\n  // Security check: ensure no users are assigned? \r\n  // For now, we'll just delete. Supabase might throw FK error if used.\r\n  const { error } = await supabase.from('roles').delete().eq('id', roleId)\r\n  \r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}\r\n\r\nexport async function createRoleAction(\r\n  companyId: string,\r\n  groupId: string,\r\n  roleName: string,\r\n  defaultLevel: number\r\n) {\r\n  const supabase = createClient()\r\n\r\n  const { error } = await supabase.from('roles').insert({\r\n    company_id: companyId,\r\n    approval_group_id: groupId,\r\n    role_name: roleName,\r\n    default_role_level: defaultLevel,\r\n    can_manage_own_company_roster: defaultLevel >= 40, // Basic logic\r\n    can_manage_all_rosters: defaultLevel >= 50\r\n  })\r\n\r\n  if (error) return { error: error.message }\r\n  revalidatePath('/manage/roles')\r\n  return { success: true }\r\n}"],"names":[],"mappings":";;;;;;;IA+LsB,mBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA","debugId":null}},
    {"offset": {"line": 359, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/components/RoleListModal.tsx"],"sourcesContent":["'use client'\r\nimport { useState, useEffect } from 'react'\r\nimport { getGroupRoles, deleteRoleAction, createRoleAction } from '../actions'\r\n\r\ninterface RoleListModalProps {\r\n  isOpen: boolean\r\n  onClose: () => void // Reverted to simple close\r\n  onRoleUpdate: () => void // NEW: Call this to refresh parent data immediately\r\n  groupName: string\r\n  groupId: string\r\n  companyName: string\r\n  companyId: string\r\n}\r\n\r\ntype Role = { id: string; role_name: string; default_role_level: number }\r\n\r\nexport default function RoleListModal({ \r\n  isOpen, onClose, onRoleUpdate, groupName, groupId, companyName, companyId \r\n}: RoleListModalProps) {\r\n  \r\n  const [roles, setRoles] = useState<Role[]>([])\r\n  const [loading, setLoading] = useState(true)\r\n  const [isAdding, setIsAdding] = useState(false)\r\n\r\n  // Builder State\r\n  const [echelon, setEchelon] = useState('1st Platoon')\r\n  const [position, setPosition] = useState('Squad Member')\r\n  const [customLevel, setCustomLevel] = useState(10)\r\n\r\n  // Handle Escape Key\r\n  useEffect(() => {\r\n    const handleKeyDown = (e: KeyboardEvent) => {\r\n      if (e.key === 'Escape') onClose()\r\n    }\r\n    if (isOpen) window.addEventListener('keydown', handleKeyDown)\r\n    return () => window.removeEventListener('keydown', handleKeyDown)\r\n  }, [isOpen, onClose])\r\n\r\n  // Fetch roles on open\r\n  useEffect(() => {\r\n    if (isOpen) {\r\n      setLoading(true)\r\n      getGroupRoles(groupId).then(res => {\r\n        setRoles(res.roles)\r\n        setLoading(false)\r\n      })\r\n    }\r\n  }, [isOpen, groupId])\r\n\r\n  const previewName = `${companyName} ${echelon} ${position}`\r\n\r\n  const handleAdd = async () => {\r\n    setLoading(true)\r\n    const res = await createRoleAction(companyId, groupId, previewName, customLevel)\r\n    if (res.error) {\r\n      alert(res.error)\r\n    } else {\r\n      const updated = await getGroupRoles(groupId)\r\n      setRoles(updated.roles)\r\n      setIsAdding(false)\r\n      // --- TRIGGER PARENT REFRESH IMMEDIATELY ---\r\n      onRoleUpdate() \r\n    }\r\n    setLoading(false)\r\n  }\r\n\r\n  const handleDelete = async (roleId: string) => {\r\n    if(!confirm(\"Delete this role? Ensure no cadets are assigned to it first.\")) return\r\n    setLoading(true)\r\n    await deleteRoleAction(roleId)\r\n    const updated = await getGroupRoles(groupId)\r\n    setRoles(updated.roles)\r\n    // --- TRIGGER PARENT REFRESH IMMEDIATELY ---\r\n    onRoleUpdate()\r\n    setLoading(false)\r\n  }\r\n\r\n  // Auto-set level based on position\r\n  useEffect(() => {\r\n    const lowerPos = position.toLowerCase()\r\n    if (lowerPos.includes('commander')) setCustomLevel(40)\r\n    else if (lowerPos.includes('sergeant major') || lowerPos.includes('1sg')) setCustomLevel(38)\r\n    else if (lowerPos.includes('platoon leader')) setCustomLevel(30)\r\n    else if (lowerPos.includes('platoon sergeant')) setCustomLevel(28)\r\n    else if (lowerPos.includes('squad leader')) setCustomLevel(20)\r\n    else setCustomLevel(10)\r\n  }, [position])\r\n\r\n  if (!isOpen) return null\r\n\r\n  return (\r\n    <div \r\n      className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm p-4\"\r\n      onClick={onClose} \r\n    >\r\n      <div \r\n        className=\"bg-white dark:bg-gray-800 rounded-xl shadow-2xl max-w-lg w-full border dark:border-gray-700 flex flex-col max-h-[85vh]\"\r\n        onClick={(e) => e.stopPropagation()}\r\n      >\r\n        {/* Header */}\r\n        <div className=\"p-6 border-b dark:border-gray-700 flex justify-between items-center\">\r\n          <div>\r\n            <h2 className=\"text-xl font-bold text-gray-900 dark:text-white\">{groupName}</h2>\r\n            <p className=\"text-sm text-gray-500\">Manage roles within this approval group.</p>\r\n          </div>\r\n          <button onClick={onClose} className=\"text-gray-400 hover:text-gray-600 dark:hover:text-gray-200\"></button>\r\n        </div>\r\n\r\n        {/* Role List */}\r\n        <div className=\"flex-1 overflow-y-auto p-6 space-y-3\">\r\n          {loading && <div className=\"text-center text-gray-500 py-4\">Loading...</div>}\r\n          \r\n          {!loading && roles.length === 0 && (\r\n            <div className=\"text-center text-gray-500 py-8 italic\">No roles in this group yet.</div>\r\n          )}\r\n\r\n          {!loading && roles.map(role => (\r\n            <div key={role.id} className=\"flex items-center justify-between p-3 bg-gray-50 dark:bg-gray-700/50 rounded-md border dark:border-gray-700\">\r\n              <div>\r\n                <div className=\"font-medium text-gray-800 dark:text-gray-200\">{role.role_name}</div>\r\n                <div className=\"text-xs text-gray-500\">Level: {role.default_role_level}</div>\r\n              </div>\r\n              <button \r\n                onClick={() => handleDelete(role.id)}\r\n                className=\"text-red-500 hover:bg-red-50 dark:hover:bg-red-900/30 p-2 rounded\"\r\n              >\r\n                <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16\" /></svg>\r\n              </button>\r\n            </div>\r\n          ))}\r\n        </div>\r\n\r\n        {/* Footer / Add Form */}\r\n        <div className=\"p-6 border-t dark:border-gray-700 bg-gray-50 dark:bg-gray-900/50 rounded-b-xl\">\r\n          {!isAdding ? (\r\n            <button \r\n              onClick={() => setIsAdding(true)}\r\n              className=\"w-full py-2 bg-indigo-600 text-white rounded-md font-medium hover:bg-indigo-700\"\r\n            >\r\n              + Add New Role\r\n            </button>\r\n          ) : (\r\n            <div className=\"space-y-4 animate-in fade-in slide-in-from-bottom-2\">\r\n              <h3 className=\"text-sm font-bold text-gray-700 dark:text-gray-300 uppercase tracking-wide\">Role Builder</h3>\r\n              \r\n              <div className=\"grid grid-cols-2 gap-4\">\r\n                <div>\r\n                  <label className=\"text-xs font-medium text-gray-500 mb-1 block\">Echelon</label>\r\n                  <select value={echelon} onChange={e => setEchelon(e.target.value)} className=\"w-full rounded text-sm border-gray-300 dark:border-gray-600 dark:bg-gray-800 dark:text-white\">\r\n                    <option>Company HQ</option>\r\n                    <option>1st Platoon</option>\r\n                    <option>2nd Platoon</option>\r\n                    <option>3rd Platoon</option>\r\n                    <option>Band</option>\r\n                  </select>\r\n                </div>\r\n                <div>\r\n                  <label className=\"text-xs font-medium text-gray-500 mb-1 block\">Position</label>\r\n                  <select value={position} onChange={e => setPosition(e.target.value)} className=\"w-full rounded text-sm border-gray-300 dark:border-gray-600 dark:bg-gray-800 dark:text-white\">\r\n                    <option>Commander</option>\r\n                    <option>Executive Officer</option>\r\n                    <option>First Sergeant</option>\r\n                    <option>Platoon Leader</option>\r\n                    <option>Platoon Sergeant</option>\r\n                    <option>Squad Leader</option>\r\n                    <option>Squad Member</option>\r\n                    <option>Clerk</option>\r\n                    <option>Armorer</option>\r\n                  </select>\r\n                </div>\r\n              </div>\r\n\r\n              <div className=\"p-3 bg-indigo-50 dark:bg-indigo-900/20 rounded border border-indigo-100 dark:border-indigo-800\">\r\n                <div className=\"text-xs text-indigo-600 dark:text-indigo-400 font-semibold mb-1\">Preview Name:</div>\r\n                <div className=\"text-sm font-mono text-gray-800 dark:text-gray-200\">{previewName}</div>\r\n              </div>\r\n\r\n              <div className=\"flex gap-3\">\r\n                <button onClick={() => setIsAdding(false)} className=\"flex-1 py-2 border border-gray-300 dark:border-gray-600 rounded text-gray-600 dark:text-gray-300 hover:bg-white dark:hover:bg-gray-700\">Cancel</button>\r\n                <button onClick={handleAdd} disabled={loading} className=\"flex-1 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700\">\r\n                  Create Role\r\n                </button>\r\n              </div>\r\n            </div>\r\n          )}\r\n        </div>\r\n\r\n      </div>\r\n    </div>\r\n  )\r\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 842, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ckhme/my-workflow-app/app/manage/roles/components/ChainVisualizer.tsx"],"sourcesContent":["// app/manage/roles/components/ChainVisualizer.tsx\r\n'use client'\r\n\r\nimport { useState, useEffect, useMemo } from 'react'\r\nimport { getCompanyChain, deleteGroupAction, createGroupAction, type ApprovalGroupNode } from '../actions'\r\nimport GroupNode from './GroupNode'\r\nimport AddGroupModal from './AddGroupModal' // We will create this next\r\nimport RoleListModal from './RoleListModal'\r\n\r\ninterface ChainVisualizerProps {\r\n  initialCompanies: { id: string; company_name: string }[]\r\n}\r\n\r\nexport default function ChainVisualizer({ initialCompanies }: ChainVisualizerProps) {\r\n  const [selectedCompanyId, setSelectedCompanyId] = useState(initialCompanies[0]?.id || '')\r\n  const [nodes, setNodes] = useState<ApprovalGroupNode[]>([])\r\n  const [loading, setLoading] = useState(false)\r\n  \r\n  \r\n  // Modal State\r\n  const [isAddModalOpen, setIsAddModalOpen] = useState(false)\r\n  const [targetChildId, setTargetChildId] = useState<string | null>(null) // The node that will report TO the new node\r\n  const [selectedNodeForRoles, setSelectedNodeForRoles] = useState<ApprovalGroupNode | null>(null)\r\n\r\n  // 1. Fetch Chain Data when Company Changes\r\n  useEffect(() => {\r\n    if (!selectedCompanyId) return\r\n    fetchChain()\r\n  }, [selectedCompanyId])\r\n\r\n  async function fetchChain() {\r\n    setLoading(true)\r\n    const data = await getCompanyChain(selectedCompanyId)\r\n    setNodes(data)\r\n    setLoading(false)\r\n  }\r\n\r\n  // 2. Actions\r\n  const handleDelete = async (id: string) => {\r\n    if (!confirm(\"Delete this group? Any groups pointing to it will be moved to its approver.\")) return\r\n    await deleteGroupAction(id)\r\n    fetchChain() // Refresh\r\n  }\r\n\r\n  const handleOpenAdd = (childId: string) => {\r\n    setTargetChildId(childId)\r\n    setIsAddModalOpen(true)\r\n  }\r\n\r\n  const handleNodeClick = (node: ApprovalGroupNode) => {\r\n  setSelectedNodeForRoles(node)\r\n}\r\n\r\n  // 3. Layout Algorithm (The \"Inverted Tree\")\r\n  // We organize nodes into columns based on how far they are from the \"Final Authority\"\r\n  const columns = useMemo(() => {\r\n    if (nodes.length === 0) return []\r\n\r\n    const depthMap = new Map<string, number>()\r\n    const adjacency = new Map<string, string[]>() // Parent -> [Children]\r\n\r\n    // Build Adjacency List (Who points to whom?)\r\n    nodes.forEach(node => {\r\n      const parent = node.next_approver_group_id || 'ROOT'\r\n      if (!adjacency.has(parent)) adjacency.set(parent, [])\r\n      adjacency.get(parent)?.push(node.id)\r\n    })\r\n\r\n    // Recursive function to determine depth (Right-to-Left)\r\n    // 0 = Final Authority\r\n    // 1 = Reports to Final\r\n    // 2 = Reports to Tier 1...\r\n    function assignDepth(nodeId: string, currentDepth: number) {\r\n      const children = adjacency.get(nodeId) || []\r\n      children.forEach(childId => {\r\n        depthMap.set(childId, currentDepth + 1) // Children are \"deeper\" (further left)\r\n        assignDepth(childId, currentDepth + 1)\r\n      })\r\n    }\r\n\r\n    // Find the roots (Nodes that either point to nothing, or point to a node NOT in this list)\r\n    // In our data, the Commandant Staff is usually the root.\r\n    // We look for 'ROOT' keys in our adjacency map from step 1.\r\n    const rootChildren = adjacency.get('ROOT') || []\r\n    \r\n    // However, if the chain leaves the company, the \"Parent\" might exist in the nodes list.\r\n    // We iterate the 'Final Authority' nodes first.\r\n    const finalNodes = nodes.filter(n => n.is_final_authority || !n.next_approver_group_id)\r\n    \r\n    finalNodes.forEach(node => {\r\n      depthMap.set(node.id, 0)\r\n      assignDepth(node.id, 0)\r\n    })\r\n\r\n    // Group by Depth\r\n    const maxDepth = Math.max(...Array.from(depthMap.values()), 0)\r\n    const cols: ApprovalGroupNode[][] = Array.from({ length: maxDepth + 1 }, () => [])\r\n\r\n    nodes.forEach(node => {\r\n      const depth = depthMap.get(node.id)\r\n      if (depth !== undefined) {\r\n        cols[depth].push(node)\r\n      }\r\n    })\r\n\r\n    // Reverse so \"Final\" (Depth 0) is on the Right\r\n    return cols.reverse()\r\n  }, [nodes])\r\n\r\n\r\n  return (\r\n    <div className=\"space-y-6\">\r\n      {/* --- TOOLBAR --- */}\r\n      <div className=\"flex items-center gap-4 bg-white dark:bg-gray-800 p-4 rounded-lg shadow\">\r\n        <label className=\"font-medium text-gray-700 dark:text-gray-300\">Select Company:</label>\r\n        <select \r\n          value={selectedCompanyId} \r\n          onChange={(e) => setSelectedCompanyId(e.target.value)}\r\n          className=\"rounded-md border-gray-300 dark:border-gray-600 dark:bg-gray-900\"\r\n        >\r\n          {initialCompanies.map(c => <option key={c.id} value={c.id}>{c.company_name}</option>)}\r\n        </select>\r\n        <button onClick={fetchChain} className=\"ml-auto text-sm text-indigo-600 hover:underline\">Refresh</button>\r\n      </div>\r\n\r\n      {/* --- VISUALIZATION CANVAS --- */}\r\n      <div className=\"overflow-x-auto pb-8 min-h-[600px] bg-gray-50 dark:bg-gray-900/50 rounded-xl border dark:border-gray-700 p-8\">\r\n        {loading ? (\r\n          <div className=\"flex items-center justify-center h-64 text-gray-500\">Loading Chain...</div>\r\n        ) : (\r\n          <div className=\"flex gap-12 min-w-max items-center\">\r\n            \r\n            {/* Render Columns */}\r\n            {columns.map((col, colIndex) => (\r\n              <div key={colIndex} className=\"flex flex-col gap-6 justify-center\">\r\n                {/* Column Header (Optional) */}\r\n                <div className=\"text-center text-xs font-bold text-gray-400 uppercase tracking-wider mb-2\">\r\n                  {colIndex === columns.length - 1 ? \"Final Approval\" : `Step ${columns.length - 1 - colIndex}`}\r\n                </div>\r\n\r\n                {/* Find the GroupNode mapping and update props */}\r\n                {col.map(node => (\r\n                    <div key={node.id} onClick={() => handleNodeClick(node)} className=\"cursor-pointer\">\r\n                        <GroupNode \r\n                        node={node} \r\n                        // FIX: Explicitly type 'e' as React.MouseEvent\r\n                        onDelete={(e: React.MouseEvent) => { \r\n                            e.stopPropagation(); \r\n                            handleDelete(node.id); \r\n                        }}\r\n                        onAddParent={(e: React.MouseEvent) => { \r\n                            e.stopPropagation(); \r\n                            handleOpenAdd(node.id); \r\n                        }}\r\n                        />\r\n                    </div>\r\n                    ))}\r\n              </div>\r\n            ))}\r\n            \r\n            {columns.length === 0 && (\r\n               <div className=\"text-gray-500\">No approval groups found for this company.</div>\r\n            )}\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* --- MODAL --- */}\r\n      {isAddModalOpen && targetChildId && (\r\n        <AddGroupModal \r\n          isOpen={isAddModalOpen}\r\n          onClose={() => setIsAddModalOpen(false)}\r\n          companyId={selectedCompanyId}\r\n          childGroupId={targetChildId}\r\n          onSuccess={() => {\r\n            setIsAddModalOpen(false)\r\n            fetchChain()\r\n          }}\r\n        />\r\n      )}\r\n      {selectedNodeForRoles && (\r\n        <RoleListModal\r\n          isOpen={!!selectedNodeForRoles}\r\n          // MODIFIED: Just close the modal.\r\n          onClose={() => setSelectedNodeForRoles(null)}\r\n          // MODIFIED: Pass the fetch function here. It will run when \"Create Role\" is clicked.\r\n          onRoleUpdate={fetchChain} \r\n          groupName={selectedNodeForRoles.group_name}\r\n          groupId={selectedNodeForRoles.id}\r\n          companyName={initialCompanies.find(c => c.id === selectedCompanyId)?.company_name || 'Unit'}\r\n          companyId={selectedCompanyId}\r\n        />\r\n      )}\r\n    </div>\r\n  )\r\n}"],"names":[],"mappings":"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","debugId":null}}]
}